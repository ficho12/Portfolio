/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("{function _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://startbootstrap-personal/./node_modules/@babel/runtime/helpers/interopRequireDefault.js?\n}");

/***/ }),

/***/ "./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Browser)\n/* harmony export */ });\nconst {\n  slice,\n  forEach\n} = [];\nfunction defaults(obj) {\n  forEach.call(slice.call(arguments, 1), source => {\n    if (source) {\n      for (const prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\nfunction hasXSS(input) {\n  if (typeof input !== 'string') return false;\n\n  // Common XSS attack patterns\n  const xssPatterns = [/<\\s*script.*?>/i, /<\\s*\\/\\s*script\\s*>/i, /<\\s*img.*?on\\w+\\s*=/i, /<\\s*\\w+\\s*on\\w+\\s*=.*?>/i, /javascript\\s*:/i, /vbscript\\s*:/i, /expression\\s*\\(/i, /eval\\s*\\(/i, /alert\\s*\\(/i, /document\\.cookie/i, /document\\.write\\s*\\(/i, /window\\.location/i, /innerHTML/i];\n  return xssPatterns.some(pattern => pattern.test(input));\n}\n\n// eslint-disable-next-line no-control-regex\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nconst serializeCookie = function (name, val) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    path: '/'\n  };\n  const opt = options;\n  const value = encodeURIComponent(val);\n  let str = `${name}=${value}`;\n  if (opt.maxAge > 0) {\n    const maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += `; Max-Age=${Math.floor(maxAge)}`;\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n    str += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n    str += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n    str += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n  if (opt.partitioned) str += '; Partitioned';\n  return str;\n};\nconst cookie = {\n  create(name, value, minutes, domain) {\n    let cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, value, cookieOptions);\n  },\n  read(name) {\n    const nameEQ = `${name}=`;\n    const ca = document.cookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n  },\n  remove(name, domain) {\n    this.create(name, '', -1, domain);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  // Deconstruct the options object and extract the lookupCookie property\n  lookup(_ref) {\n    let {\n      lookupCookie\n    } = _ref;\n    if (lookupCookie && typeof document !== 'undefined') {\n      return cookie.read(lookupCookie) || undefined;\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupCookie,\n      cookieMinutes,\n      cookieDomain,\n      cookieOptions\n    } = _ref2;\n    if (lookupCookie && typeof document !== 'undefined') {\n      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);\n    }\n  }\n};\n\nvar querystring = {\n  name: 'querystring',\n  // Deconstruct the options object and extract the lookupQuerystring property\n  lookup(_ref) {\n    let {\n      lookupQuerystring\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      let {\n        search\n      } = window.location;\n      if (!window.location.search && window.location.hash?.indexOf('?') > -1) {\n        search = window.location.hash.substring(window.location.hash.indexOf('?'));\n      }\n      const query = search.substring(1);\n      const params = query.split('&');\n      for (let i = 0; i < params.length; i++) {\n        const pos = params[i].indexOf('=');\n        if (pos > 0) {\n          const key = params[i].substring(0, pos);\n          if (key === lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n    return found;\n  }\n};\n\nvar hash = {\n  name: 'hash',\n  // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property\n  lookup(_ref) {\n    let {\n      lookupHash,\n      lookupFromHashIndex\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      const {\n        hash\n      } = window.location;\n      if (hash && hash.length > 2) {\n        const query = hash.substring(1);\n        if (lookupHash) {\n          const params = query.split('&');\n          for (let i = 0; i < params.length; i++) {\n            const pos = params[i].indexOf('=');\n            if (pos > 0) {\n              const key = params[i].substring(0, pos);\n              if (key === lookupHash) {\n                found = params[i].substring(pos + 1);\n              }\n            }\n          }\n        }\n        if (found) return found;\n        if (!found && lookupFromHashIndex > -1) {\n          const language = hash.match(/\\/([a-zA-Z-]*)/g);\n          if (!Array.isArray(language)) return undefined;\n          const index = typeof lookupFromHashIndex === 'number' ? lookupFromHashIndex : 0;\n          return language[index]?.replace('/', '');\n        }\n      }\n    }\n    return found;\n  }\n};\n\nlet hasLocalStorageSupport = null;\nconst localStorageAvailable = () => {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n  try {\n    hasLocalStorageSupport = typeof window !== 'undefined' && window.localStorage !== null;\n    if (!hasLocalStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n  return hasLocalStorageSupport;\n};\nvar localStorage = {\n  name: 'localStorage',\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  lookup(_ref) {\n    let {\n      lookupLocalStorage\n    } = _ref;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      return window.localStorage.getItem(lookupLocalStorage) || undefined; // Undefined ensures type consistency with the previous version of this function\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupLocalStorage\n    } = _ref2;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(lookupLocalStorage, lng);\n    }\n  }\n};\n\nlet hasSessionStorageSupport = null;\nconst sessionStorageAvailable = () => {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n  try {\n    hasSessionStorageSupport = typeof window !== 'undefined' && window.sessionStorage !== null;\n    if (!hasSessionStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n  return hasSessionStorageSupport;\n};\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup(_ref) {\n    let {\n      lookupSessionStorage\n    } = _ref;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      return window.sessionStorage.getItem(lookupSessionStorage) || undefined;\n    }\n    return undefined;\n  },\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupSessionStorage\n    } = _ref2;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(lookupSessionStorage, lng);\n    }\n  }\n};\n\nvar navigator$1 = {\n  name: 'navigator',\n  lookup(options) {\n    const found = [];\n    if (typeof navigator !== 'undefined') {\n      const {\n        languages,\n        userLanguage,\n        language\n      } = navigator;\n      if (languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (let i = 0; i < languages.length; i++) {\n          found.push(languages[i]);\n        }\n      }\n      if (userLanguage) {\n        found.push(userLanguage);\n      }\n      if (language) {\n        found.push(language);\n      }\n    }\n    return found.length > 0 ? found : undefined;\n  }\n};\n\nvar htmlTag = {\n  name: 'htmlTag',\n  // Deconstruct the options object and extract the htmlTag property\n  lookup(_ref) {\n    let {\n      htmlTag\n    } = _ref;\n    let found;\n    const internalHtmlTag = htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === 'function') {\n      found = internalHtmlTag.getAttribute('lang');\n    }\n    return found;\n  }\n};\n\nvar path = {\n  name: 'path',\n  // Deconstruct the options object and extract the lookupFromPathIndex property\n  lookup(_ref) {\n    let {\n      lookupFromPathIndex\n    } = _ref;\n    if (typeof window === 'undefined') return undefined;\n    const language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n    if (!Array.isArray(language)) return undefined;\n    const index = typeof lookupFromPathIndex === 'number' ? lookupFromPathIndex : 0;\n    return language[index]?.replace('/', '');\n  }\n};\n\nvar subdomain = {\n  name: 'subdomain',\n  lookup(_ref) {\n    let {\n      lookupFromSubdomainIndex\n    } = _ref;\n    // If given get the subdomain index else 1\n    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === 'number' ? lookupFromSubdomainIndex + 1 : 1;\n    // get all matches if window.location. is existing\n    // first item of match is the match itself and the second is the first group match which should be the first subdomain match\n    // is the hostname no public domain get the or option of localhost\n    const language = typeof window !== 'undefined' && window.location?.hostname?.match(/^(\\w{2,5})\\.(([a-z0-9-]{1,63}\\.[a-z]{2,6})|localhost)/i);\n\n    // if there is no match (null) return undefined\n    if (!language) return undefined;\n    // return the given group match\n    return language[internalLookupFromSubdomainIndex];\n  }\n};\n\n// some environments, throws when accessing document.cookie\nlet canCookies = false;\ntry {\n  // eslint-disable-next-line no-unused-expressions\n  document.cookie;\n  canCookies = true;\n  // eslint-disable-next-line no-empty\n} catch (e) {}\nconst order = ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'];\nif (!canCookies) order.splice(1, 1);\nconst getDefaults = () => ({\n  order,\n  lookupQuerystring: 'lng',\n  lookupCookie: 'i18next',\n  lookupLocalStorage: 'i18nextLng',\n  lookupSessionStorage: 'i18nextLng',\n  // cache user language\n  caches: ['localStorage'],\n  excludeCacheFor: ['cimode'],\n  // cookieMinutes: 10,\n  // cookieDomain: 'myDomain'\n\n  convertDetectedLanguage: l => l\n});\nclass Browser {\n  constructor(services) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n  init() {\n    let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      languageUtils: {}\n    };\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.services = services;\n    this.options = defaults(options, this.options || {}, getDefaults());\n    if (typeof this.options.convertDetectedLanguage === 'string' && this.options.convertDetectedLanguage.indexOf('15897') > -1) {\n      this.options.convertDetectedLanguage = l => l.replace('-', '_');\n    }\n\n    // backwards compatibility\n    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n    this.i18nOptions = i18nOptions;\n    this.addDetector(cookie$1);\n    this.addDetector(querystring);\n    this.addDetector(localStorage);\n    this.addDetector(sessionStorage);\n    this.addDetector(navigator$1);\n    this.addDetector(htmlTag);\n    this.addDetector(path);\n    this.addDetector(subdomain);\n    this.addDetector(hash);\n  }\n  addDetector(detector) {\n    this.detectors[detector.name] = detector;\n    return this;\n  }\n  detect() {\n    let detectionOrder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.order;\n    let detected = [];\n    detectionOrder.forEach(detectorName => {\n      if (this.detectors[detectorName]) {\n        let lookup = this.detectors[detectorName].lookup(this.options);\n        if (lookup && typeof lookup === 'string') lookup = [lookup];\n        if (lookup) detected = detected.concat(lookup);\n      }\n    });\n    detected = detected.filter(d => d !== undefined && d !== null && !hasXSS(d)).map(d => this.options.convertDetectedLanguage(d));\n    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n    return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n  }\n  cacheUserLanguage(lng) {\n    let caches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.caches;\n    if (!caches) return;\n    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n    caches.forEach(cacheName => {\n      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);\n    });\n  }\n}\nBrowser.type = 'languageDetector';\n\n\n\n\n//# sourceURL=webpack://startbootstrap-personal/./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js?\n}");

/***/ }),

/***/ "./node_modules/i18next/dist/cjs/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/cjs/i18next.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nconst isString = obj => typeof obj === 'string';\nconst defer = () => {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n};\nconst makeString = object => {\n  if (object == null) return '';\n  return '' + object;\n};\nconst copy = (a, s, t) => {\n  a.forEach(m => {\n    if (s[m]) t[m] = s[m];\n  });\n};\nconst lastOfPathSeparatorRegExp = /###/g;\nconst cleanKey = key => key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;\nconst canNotTraverseDeeper = object => !object || isString(object);\nconst getLastOfPath = (object, path, Empty) => {\n  const stack = !isString(path) ? path : path.split('.');\n  let stackIndex = 0;\n  while (stackIndex < stack.length - 1) {\n    if (canNotTraverseDeeper(object)) return {};\n    const key = cleanKey(stack[stackIndex]);\n    if (!object[key] && Empty) object[key] = new Empty();\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      object = object[key];\n    } else {\n      object = {};\n    }\n    ++stackIndex;\n  }\n  if (canNotTraverseDeeper(object)) return {};\n  return {\n    obj: object,\n    k: cleanKey(stack[stackIndex])\n  };\n};\nconst setPath = (object, path, newValue) => {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path, Object);\n  if (obj !== undefined || path.length === 1) {\n    obj[k] = newValue;\n    return;\n  }\n  let e = path[path.length - 1];\n  let p = path.slice(0, path.length - 1);\n  let last = getLastOfPath(object, p, Object);\n  while (last.obj === undefined && p.length) {\n    e = `${p[p.length - 1]}.${e}`;\n    p = p.slice(0, p.length - 1);\n    last = getLastOfPath(object, p, Object);\n    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== 'undefined') {\n      last.obj = undefined;\n    }\n  }\n  last.obj[`${last.k}.${e}`] = newValue;\n};\nconst pushPath = (object, path, newValue, concat) => {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path, Object);\n  obj[k] = obj[k] || [];\n  obj[k].push(newValue);\n};\nconst getPath = (object, path) => {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path);\n  if (!obj) return undefined;\n  if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;\n  return obj[k];\n};\nconst getPathWithDefaults = (data, defaultData, key) => {\n  const value = getPath(data, key);\n  if (value !== undefined) {\n    return value;\n  }\n  return getPath(defaultData, key);\n};\nconst deepExtend = (target, source, overwrite) => {\n  for (const prop in source) {\n    if (prop !== '__proto__' && prop !== 'constructor') {\n      if (prop in target) {\n        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {\n          if (overwrite) target[prop] = source[prop];\n        } else {\n          deepExtend(target[prop], source[prop], overwrite);\n        }\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n  }\n  return target;\n};\nconst regexEscape = str => str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\nvar _entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;'\n};\nconst escape = data => {\n  if (isString(data)) {\n    return data.replace(/[&<>\"'\\/]/g, s => _entityMap[s]);\n  }\n  return data;\n};\nclass RegExpCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.regExpMap = new Map();\n    this.regExpQueue = [];\n  }\n  getRegExp(pattern) {\n    const regExpFromCache = this.regExpMap.get(pattern);\n    if (regExpFromCache !== undefined) {\n      return regExpFromCache;\n    }\n    const regExpNew = new RegExp(pattern);\n    if (this.regExpQueue.length === this.capacity) {\n      this.regExpMap.delete(this.regExpQueue.shift());\n    }\n    this.regExpMap.set(pattern, regExpNew);\n    this.regExpQueue.push(pattern);\n    return regExpNew;\n  }\n}\nconst chars = [' ', ',', '?', '!', ';'];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nconst looksLikeObjectPath = (key, nsSeparator, keySeparator) => {\n  nsSeparator = nsSeparator || '';\n  keySeparator = keySeparator || '';\n  const possibleChars = chars.filter(c => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n  if (possibleChars.length === 0) return true;\n  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map(c => c === '?' ? '\\\\?' : c).join('|')})`);\n  let matched = !r.test(key);\n  if (!matched) {\n    const ki = key.indexOf(keySeparator);\n    if (ki > 0 && !r.test(key.substring(0, ki))) {\n      matched = true;\n    }\n  }\n  return matched;\n};\nconst deepFind = (obj, path, keySeparator = '.') => {\n  if (!obj) return undefined;\n  if (obj[path]) {\n    if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;\n    return obj[path];\n  }\n  const tokens = path.split(keySeparator);\n  let current = obj;\n  for (let i = 0; i < tokens.length;) {\n    if (!current || typeof current !== 'object') {\n      return undefined;\n    }\n    let next;\n    let nextPath = '';\n    for (let j = i; j < tokens.length; ++j) {\n      if (j !== i) {\n        nextPath += keySeparator;\n      }\n      nextPath += tokens[j];\n      next = current[nextPath];\n      if (next !== undefined) {\n        if (['string', 'number', 'boolean'].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n          continue;\n        }\n        i += j - i + 1;\n        break;\n      }\n    }\n    current = next;\n  }\n  return current;\n};\nconst getCleanedCode = code => code?.replace('_', '-');\n\nconst consoleLogger = {\n  type: 'logger',\n  log(args) {\n    this.output('log', args);\n  },\n  warn(args) {\n    this.output('warn', args);\n  },\n  error(args) {\n    this.output('error', args);\n  },\n  output(type, args) {\n    console?.[type]?.apply?.(console, args);\n  }\n};\nclass Logger {\n  constructor(concreteLogger, options = {}) {\n    this.init(concreteLogger, options);\n  }\n  init(concreteLogger, options = {}) {\n    this.prefix = options.prefix || 'i18next:';\n    this.logger = concreteLogger || consoleLogger;\n    this.options = options;\n    this.debug = options.debug;\n  }\n  log(...args) {\n    return this.forward(args, 'log', '', true);\n  }\n  warn(...args) {\n    return this.forward(args, 'warn', '', true);\n  }\n  error(...args) {\n    return this.forward(args, 'error', '');\n  }\n  deprecate(...args) {\n    return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n  }\n  forward(args, lvl, prefix, debugOnly) {\n    if (debugOnly && !this.debug) return null;\n    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;\n    return this.logger[lvl](args);\n  }\n  create(moduleName) {\n    return new Logger(this.logger, {\n      ...{\n        prefix: `${this.prefix}:${moduleName}:`\n      },\n      ...this.options\n    });\n  }\n  clone(options) {\n    options = options || this.options;\n    options.prefix = options.prefix || this.prefix;\n    return new Logger(this.logger, options);\n  }\n}\nvar baseLogger = new Logger();\n\nclass EventEmitter {\n  constructor() {\n    this.observers = {};\n  }\n  on(events, listener) {\n    events.split(' ').forEach(event => {\n      if (!this.observers[event]) this.observers[event] = new Map();\n      const numListeners = this.observers[event].get(listener) || 0;\n      this.observers[event].set(listener, numListeners + 1);\n    });\n    return this;\n  }\n  off(event, listener) {\n    if (!this.observers[event]) return;\n    if (!listener) {\n      delete this.observers[event];\n      return;\n    }\n    this.observers[event].delete(listener);\n  }\n  emit(event, ...args) {\n    if (this.observers[event]) {\n      const cloned = Array.from(this.observers[event].entries());\n      cloned.forEach(([observer, numTimesAdded]) => {\n        for (let i = 0; i < numTimesAdded; i++) {\n          observer(...args);\n        }\n      });\n    }\n    if (this.observers['*']) {\n      const cloned = Array.from(this.observers['*'].entries());\n      cloned.forEach(([observer, numTimesAdded]) => {\n        for (let i = 0; i < numTimesAdded; i++) {\n          observer.apply(observer, [event, ...args]);\n        }\n      });\n    }\n  }\n}\n\nclass ResourceStore extends EventEmitter {\n  constructor(data, options = {\n    ns: ['translation'],\n    defaultNS: 'translation'\n  }) {\n    super();\n    this.data = data || {};\n    this.options = options;\n    if (this.options.keySeparator === undefined) {\n      this.options.keySeparator = '.';\n    }\n    if (this.options.ignoreJSONStructure === undefined) {\n      this.options.ignoreJSONStructure = true;\n    }\n  }\n  addNamespaces(ns) {\n    if (this.options.ns.indexOf(ns) < 0) {\n      this.options.ns.push(ns);\n    }\n  }\n  removeNamespaces(ns) {\n    const index = this.options.ns.indexOf(ns);\n    if (index > -1) {\n      this.options.ns.splice(index, 1);\n    }\n  }\n  getResource(lng, ns, key, options = {}) {\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n    let path;\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n    } else {\n      path = [lng, ns];\n      if (key) {\n        if (Array.isArray(key)) {\n          path.push(...key);\n        } else if (isString(key) && keySeparator) {\n          path.push(...key.split(keySeparator));\n        } else {\n          path.push(key);\n        }\n      }\n    }\n    const result = getPath(this.data, path);\n    if (!result && !ns && !key && lng.indexOf('.') > -1) {\n      lng = path[0];\n      ns = path[1];\n      key = path.slice(2).join('.');\n    }\n    if (result || !ignoreJSONStructure || !isString(key)) return result;\n    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);\n  }\n  addResource(lng, ns, key, value, options = {\n    silent: false\n  }) {\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    let path = [lng, ns];\n    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n      value = ns;\n      ns = path[1];\n    }\n    this.addNamespaces(ns);\n    setPath(this.data, path, value);\n    if (!options.silent) this.emit('added', lng, ns, key, value);\n  }\n  addResources(lng, ns, resources, options = {\n    silent: false\n  }) {\n    for (const m in resources) {\n      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n        silent: true\n      });\n    }\n    if (!options.silent) this.emit('added', lng, ns, resources);\n  }\n  addResourceBundle(lng, ns, resources, deep, overwrite, options = {\n    silent: false,\n    skipCopy: false\n  }) {\n    let path = [lng, ns];\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n      deep = resources;\n      resources = ns;\n      ns = path[1];\n    }\n    this.addNamespaces(ns);\n    let pack = getPath(this.data, path) || {};\n    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n    if (deep) {\n      deepExtend(pack, resources, overwrite);\n    } else {\n      pack = {\n        ...pack,\n        ...resources\n      };\n    }\n    setPath(this.data, path, pack);\n    if (!options.silent) this.emit('added', lng, ns, resources);\n  }\n  removeResourceBundle(lng, ns) {\n    if (this.hasResourceBundle(lng, ns)) {\n      delete this.data[lng][ns];\n    }\n    this.removeNamespaces(ns);\n    this.emit('removed', lng, ns);\n  }\n  hasResourceBundle(lng, ns) {\n    return this.getResource(lng, ns) !== undefined;\n  }\n  getResourceBundle(lng, ns) {\n    if (!ns) ns = this.options.defaultNS;\n    return this.getResource(lng, ns);\n  }\n  getDataByLanguage(lng) {\n    return this.data[lng];\n  }\n  hasLanguageSomeTranslations(lng) {\n    const data = this.getDataByLanguage(lng);\n    const n = data && Object.keys(data) || [];\n    return !!n.find(v => data[v] && Object.keys(data[v]).length > 0);\n  }\n  toJSON() {\n    return this.data;\n  }\n}\n\nvar postProcessor = {\n  processors: {},\n  addPostProcessor(module) {\n    this.processors[module.name] = module;\n  },\n  handle(processors, value, key, options, translator) {\n    processors.forEach(processor => {\n      value = this.processors[processor]?.process(value, key, options, translator) ?? value;\n    });\n    return value;\n  }\n};\n\nconst PATH_KEY = Symbol('i18next/PATH_KEY');\nfunction createProxy() {\n  const state = [];\n  const handler = Object.create(null);\n  let proxy;\n  handler.get = (target, key) => {\n    proxy?.revoke?.();\n    if (key === PATH_KEY) return state;\n    state.push(key);\n    proxy = Proxy.revocable(target, handler);\n    return proxy.proxy;\n  };\n  return Proxy.revocable(Object.create(null), handler).proxy;\n}\nfunction keysFromSelector(selector, opts) {\n  const {\n    [PATH_KEY]: path\n  } = selector(createProxy());\n  return path.join(opts?.keySeparator ?? '.');\n}\n\nconst checkedLoadedFor = {};\nconst shouldHandleAsObject = res => !isString(res) && typeof res !== 'boolean' && typeof res !== 'number';\nclass Translator extends EventEmitter {\n  constructor(services, options = {}) {\n    super();\n    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, this);\n    this.options = options;\n    if (this.options.keySeparator === undefined) {\n      this.options.keySeparator = '.';\n    }\n    this.logger = baseLogger.create('translator');\n  }\n  changeLanguage(lng) {\n    if (lng) this.language = lng;\n  }\n  exists(key, o = {\n    interpolation: {}\n  }) {\n    const opt = {\n      ...o\n    };\n    if (key == null) return false;\n    const resolved = this.resolve(key, opt);\n    return resolved?.res !== undefined;\n  }\n  extractFromKey(key, opt) {\n    let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n    if (nsSeparator === undefined) nsSeparator = ':';\n    const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n    let namespaces = opt.ns || this.options.defaultNS || [];\n    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n      const m = key.match(this.interpolator.nestingRegexp);\n      if (m && m.length > 0) {\n        return {\n          key,\n          namespaces: isString(namespaces) ? [namespaces] : namespaces\n        };\n      }\n      const parts = key.split(nsSeparator);\n      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n      key = parts.join(keySeparator);\n    }\n    return {\n      key,\n      namespaces: isString(namespaces) ? [namespaces] : namespaces\n    };\n  }\n  translate(keys, o, lastKey) {\n    let opt = typeof o === 'object' ? {\n      ...o\n    } : o;\n    if (typeof opt !== 'object' && this.options.overloadTranslationOptionHandler) {\n      opt = this.options.overloadTranslationOptionHandler(arguments);\n    }\n    if (typeof options === 'object') opt = {\n      ...opt\n    };\n    if (!opt) opt = {};\n    if (keys == null) return '';\n    if (typeof keys === 'function') keys = keysFromSelector(keys, opt);\n    if (!Array.isArray(keys)) keys = [String(keys)];\n    const returnDetails = opt.returnDetails !== undefined ? opt.returnDetails : this.options.returnDetails;\n    const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n    const {\n      key,\n      namespaces\n    } = this.extractFromKey(keys[keys.length - 1], opt);\n    const namespace = namespaces[namespaces.length - 1];\n    let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n    if (nsSeparator === undefined) nsSeparator = ':';\n    const lng = opt.lng || this.language;\n    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n    if (lng?.toLowerCase() === 'cimode') {\n      if (appendNamespaceToCIMode) {\n        if (returnDetails) {\n          return {\n            res: `${namespace}${nsSeparator}${key}`,\n            usedKey: key,\n            exactUsedKey: key,\n            usedLng: lng,\n            usedNS: namespace,\n            usedParams: this.getUsedParamsDetails(opt)\n          };\n        }\n        return `${namespace}${nsSeparator}${key}`;\n      }\n      if (returnDetails) {\n        return {\n          res: key,\n          usedKey: key,\n          exactUsedKey: key,\n          usedLng: lng,\n          usedNS: namespace,\n          usedParams: this.getUsedParamsDetails(opt)\n        };\n      }\n      return key;\n    }\n    const resolved = this.resolve(keys, opt);\n    let res = resolved?.res;\n    const resUsedKey = resolved?.usedKey || key;\n    const resExactUsedKey = resolved?.exactUsedKey || key;\n    const noObject = ['[object Number]', '[object Function]', '[object RegExp]'];\n    const joinArrays = opt.joinArrays !== undefined ? opt.joinArrays : this.options.joinArrays;\n    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n    const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n    const hasDefaultValue = Translator.hasDefaultValue(opt);\n    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : '';\n    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {\n      ordinal: false\n    }) : '';\n    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;\n    let resForObjHndl = res;\n    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {\n      resForObjHndl = defaultValue;\n    }\n    const handleAsObject = shouldHandleAsObject(resForObjHndl);\n    const resType = Object.prototype.toString.apply(resForObjHndl);\n    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {\n      if (!opt.returnObjects && !this.options.returnObjects) {\n        if (!this.options.returnedObjectHandler) {\n          this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n        }\n        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {\n          ...opt,\n          ns: namespaces\n        }) : `key '${key} (${this.language})' returned an object instead of string.`;\n        if (returnDetails) {\n          resolved.res = r;\n          resolved.usedParams = this.getUsedParamsDetails(opt);\n          return resolved;\n        }\n        return r;\n      }\n      if (keySeparator) {\n        const resTypeIsArray = Array.isArray(resForObjHndl);\n        const copy = resTypeIsArray ? [] : {};\n        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n        for (const m in resForObjHndl) {\n          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {\n            const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n            if (hasDefaultValue && !res) {\n              copy[m] = this.translate(deepKey, {\n                ...opt,\n                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,\n                ...{\n                  joinArrays: false,\n                  ns: namespaces\n                }\n              });\n            } else {\n              copy[m] = this.translate(deepKey, {\n                ...opt,\n                ...{\n                  joinArrays: false,\n                  ns: namespaces\n                }\n              });\n            }\n            if (copy[m] === deepKey) copy[m] = resForObjHndl[m];\n          }\n        }\n        res = copy;\n      }\n    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {\n      res = res.join(joinArrays);\n      if (res) res = this.extendTranslation(res, keys, opt, lastKey);\n    } else {\n      let usedDefault = false;\n      let usedKey = false;\n      if (!this.isValidLookup(res) && hasDefaultValue) {\n        usedDefault = true;\n        res = defaultValue;\n      }\n      if (!this.isValidLookup(res)) {\n        usedKey = true;\n        res = key;\n      }\n      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n      if (usedKey || usedDefault || updateMissing) {\n        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);\n        if (keySeparator) {\n          const fk = this.resolve(key, {\n            ...opt,\n            keySeparator: false\n          });\n          if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n        }\n        let lngs = [];\n        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);\n        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n          for (let i = 0; i < fallbackLngs.length; i++) {\n            lngs.push(fallbackLngs[i]);\n          }\n        } else if (this.options.saveMissingTo === 'all') {\n          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);\n        } else {\n          lngs.push(opt.lng || this.language);\n        }\n        const send = (l, k, specificDefaultValue) => {\n          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n          if (this.options.missingKeyHandler) {\n            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);\n          } else if (this.backendConnector?.saveMissing) {\n            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);\n          }\n          this.emit('missingKey', l, namespace, k, res);\n        };\n        if (this.options.saveMissing) {\n          if (this.options.saveMissingPlurals && needsPluralHandling) {\n            lngs.forEach(language => {\n              const suffixes = this.pluralResolver.getSuffixes(language, opt);\n              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                suffixes.push(`${this.options.pluralSeparator}zero`);\n              }\n              suffixes.forEach(suffix => {\n                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);\n              });\n            });\n          } else {\n            send(lngs, key, defaultValue);\n          }\n        }\n      }\n      res = this.extendTranslation(res, keys, opt, resolved, lastKey);\n      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {\n        res = `${namespace}${nsSeparator}${key}`;\n      }\n      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : undefined, opt);\n      }\n    }\n    if (returnDetails) {\n      resolved.res = res;\n      resolved.usedParams = this.getUsedParamsDetails(opt);\n      return resolved;\n    }\n    return res;\n  }\n  extendTranslation(res, key, opt, resolved, lastKey) {\n    if (this.i18nFormat?.parse) {\n      res = this.i18nFormat.parse(res, {\n        ...this.options.interpolation.defaultVariables,\n        ...opt\n      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n        resolved\n      });\n    } else if (!opt.skipInterpolation) {\n      if (opt.interpolation) this.interpolator.init({\n        ...opt,\n        ...{\n          interpolation: {\n            ...this.options.interpolation,\n            ...opt.interpolation\n          }\n        }\n      });\n      const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== undefined ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n      let nestBef;\n      if (skipOnVariables) {\n        const nb = res.match(this.interpolator.nestingRegexp);\n        nestBef = nb && nb.length;\n      }\n      let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;\n      if (this.options.interpolation.defaultVariables) data = {\n        ...this.options.interpolation.defaultVariables,\n        ...data\n      };\n      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);\n      if (skipOnVariables) {\n        const na = res.match(this.interpolator.nestingRegexp);\n        const nestAft = na && na.length;\n        if (nestBef < nestAft) opt.nest = false;\n      }\n      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;\n      if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {\n        if (lastKey?.[0] === args[0] && !opt.context) {\n          this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n          return null;\n        }\n        return this.translate(...args, key);\n      }, opt);\n      if (opt.interpolation) this.interpolator.reset();\n    }\n    const postProcess = opt.postProcess || this.options.postProcess;\n    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;\n    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {\n      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n        i18nResolved: {\n          ...resolved,\n          usedParams: this.getUsedParamsDetails(opt)\n        },\n        ...opt\n      } : opt, this);\n    }\n    return res;\n  }\n  resolve(keys, opt = {}) {\n    let found;\n    let usedKey;\n    let exactUsedKey;\n    let usedLng;\n    let usedNS;\n    if (isString(keys)) keys = [keys];\n    keys.forEach(k => {\n      if (this.isValidLookup(found)) return;\n      const extracted = this.extractFromKey(k, opt);\n      const key = extracted.key;\n      usedKey = key;\n      let namespaces = extracted.namespaces;\n      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n      const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n      const needsContextHandling = opt.context !== undefined && (isString(opt.context) || typeof opt.context === 'number') && opt.context !== '';\n      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);\n      namespaces.forEach(ns => {\n        if (this.isValidLookup(found)) return;\n        usedNS = ns;\n        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {\n          checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n          this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(', ')}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n        }\n        codes.forEach(code => {\n          if (this.isValidLookup(found)) return;\n          usedLng = code;\n          const finalKeys = [key];\n          if (this.i18nFormat?.addLookupKeys) {\n            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);\n          } else {\n            let pluralSuffix;\n            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);\n            const zeroSuffix = `${this.options.pluralSeparator}zero`;\n            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n            if (needsPluralHandling) {\n              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n              }\n              finalKeys.push(key + pluralSuffix);\n              if (needsZeroSuffixLookup) {\n                finalKeys.push(key + zeroSuffix);\n              }\n            }\n            if (needsContextHandling) {\n              const contextKey = `${key}${this.options.contextSeparator || '_'}${opt.context}`;\n              finalKeys.push(contextKey);\n              if (needsPluralHandling) {\n                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                }\n                finalKeys.push(contextKey + pluralSuffix);\n                if (needsZeroSuffixLookup) {\n                  finalKeys.push(contextKey + zeroSuffix);\n                }\n              }\n            }\n          }\n          let possibleKey;\n          while (possibleKey = finalKeys.pop()) {\n            if (!this.isValidLookup(found)) {\n              exactUsedKey = possibleKey;\n              found = this.getResource(code, ns, possibleKey, opt);\n            }\n          }\n        });\n      });\n    });\n    return {\n      res: found,\n      usedKey,\n      exactUsedKey,\n      usedLng,\n      usedNS\n    };\n  }\n  isValidLookup(res) {\n    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n  }\n  getResource(code, ns, key, options = {}) {\n    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n    return this.resourceStore.getResource(code, ns, key, options);\n  }\n  getUsedParamsDetails(options = {}) {\n    const optionsKeys = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'];\n    const useOptionsReplaceForData = options.replace && !isString(options.replace);\n    let data = useOptionsReplaceForData ? options.replace : options;\n    if (useOptionsReplaceForData && typeof options.count !== 'undefined') {\n      data.count = options.count;\n    }\n    if (this.options.interpolation.defaultVariables) {\n      data = {\n        ...this.options.interpolation.defaultVariables,\n        ...data\n      };\n    }\n    if (!useOptionsReplaceForData) {\n      data = {\n        ...data\n      };\n      for (const key of optionsKeys) {\n        delete data[key];\n      }\n    }\n    return data;\n  }\n  static hasDefaultValue(options) {\n    const prefix = 'defaultValue';\n    for (const option in options) {\n      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nclass LanguageUtil {\n  constructor(options) {\n    this.options = options;\n    this.supportedLngs = this.options.supportedLngs || false;\n    this.logger = baseLogger.create('languageUtils');\n  }\n  getScriptPartFromCode(code) {\n    code = getCleanedCode(code);\n    if (!code || code.indexOf('-') < 0) return null;\n    const p = code.split('-');\n    if (p.length === 2) return null;\n    p.pop();\n    if (p[p.length - 1].toLowerCase() === 'x') return null;\n    return this.formatLanguageCode(p.join('-'));\n  }\n  getLanguagePartFromCode(code) {\n    code = getCleanedCode(code);\n    if (!code || code.indexOf('-') < 0) return code;\n    const p = code.split('-');\n    return this.formatLanguageCode(p[0]);\n  }\n  formatLanguageCode(code) {\n    if (isString(code) && code.indexOf('-') > -1) {\n      let formattedCode;\n      try {\n        formattedCode = Intl.getCanonicalLocales(code)[0];\n      } catch (e) {}\n      if (formattedCode && this.options.lowerCaseLng) {\n        formattedCode = formattedCode.toLowerCase();\n      }\n      if (formattedCode) return formattedCode;\n      if (this.options.lowerCaseLng) {\n        return code.toLowerCase();\n      }\n      return code;\n    }\n    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n  }\n  isSupportedCode(code) {\n    if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n      code = this.getLanguagePartFromCode(code);\n    }\n    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n  }\n  getBestMatchFromCodes(codes) {\n    if (!codes) return null;\n    let found;\n    codes.forEach(code => {\n      if (found) return;\n      const cleanedLng = this.formatLanguageCode(code);\n      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n    });\n    if (!found && this.options.supportedLngs) {\n      codes.forEach(code => {\n        if (found) return;\n        const lngScOnly = this.getScriptPartFromCode(code);\n        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;\n        const lngOnly = this.getLanguagePartFromCode(code);\n        if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n        found = this.options.supportedLngs.find(supportedLng => {\n          if (supportedLng === lngOnly) return supportedLng;\n          if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;\n          if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;\n          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n        });\n      });\n    }\n    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n    return found;\n  }\n  getFallbackCodes(fallbacks, code) {\n    if (!fallbacks) return [];\n    if (typeof fallbacks === 'function') fallbacks = fallbacks(code);\n    if (isString(fallbacks)) fallbacks = [fallbacks];\n    if (Array.isArray(fallbacks)) return fallbacks;\n    if (!code) return fallbacks.default || [];\n    let found = fallbacks[code];\n    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n    if (!found) found = fallbacks[this.formatLanguageCode(code)];\n    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n    if (!found) found = fallbacks.default;\n    return found || [];\n  }\n  toResolveHierarchy(code, fallbackCode) {\n    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);\n    const codes = [];\n    const addCode = c => {\n      if (!c) return;\n      if (this.isSupportedCode(c)) {\n        codes.push(c);\n      } else {\n        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n      }\n    };\n    if (isString(code) && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {\n      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));\n      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));\n      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));\n    } else if (isString(code)) {\n      addCode(this.formatLanguageCode(code));\n    }\n    fallbackCodes.forEach(fc => {\n      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n    });\n    return codes;\n  }\n}\n\nconst suffixesOrder = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  few: 3,\n  many: 4,\n  other: 5\n};\nconst dummyRule = {\n  select: count => count === 1 ? 'one' : 'other',\n  resolvedOptions: () => ({\n    pluralCategories: ['one', 'other']\n  })\n};\nclass PluralResolver {\n  constructor(languageUtils, options = {}) {\n    this.languageUtils = languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('pluralResolver');\n    this.pluralRulesCache = {};\n  }\n  addRule(lng, obj) {\n    this.rules[lng] = obj;\n  }\n  clearCache() {\n    this.pluralRulesCache = {};\n  }\n  getRule(code, options = {}) {\n    const cleanedCode = getCleanedCode(code === 'dev' ? 'en' : code);\n    const type = options.ordinal ? 'ordinal' : 'cardinal';\n    const cacheKey = JSON.stringify({\n      cleanedCode,\n      type\n    });\n    if (cacheKey in this.pluralRulesCache) {\n      return this.pluralRulesCache[cacheKey];\n    }\n    let rule;\n    try {\n      rule = new Intl.PluralRules(cleanedCode, {\n        type\n      });\n    } catch (err) {\n      if (!Intl) {\n        this.logger.error('No Intl support, please use an Intl polyfill!');\n        return dummyRule;\n      }\n      if (!code.match(/-|_/)) return dummyRule;\n      const lngPart = this.languageUtils.getLanguagePartFromCode(code);\n      rule = this.getRule(lngPart, options);\n    }\n    this.pluralRulesCache[cacheKey] = rule;\n    return rule;\n  }\n  needsPlural(code, options = {}) {\n    let rule = this.getRule(code, options);\n    if (!rule) rule = this.getRule('dev', options);\n    return rule?.resolvedOptions().pluralCategories.length > 1;\n  }\n  getPluralFormsOfKey(code, key, options = {}) {\n    return this.getSuffixes(code, options).map(suffix => `${key}${suffix}`);\n  }\n  getSuffixes(code, options = {}) {\n    let rule = this.getRule(code, options);\n    if (!rule) rule = this.getRule('dev', options);\n    if (!rule) return [];\n    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map(pluralCategory => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${pluralCategory}`);\n  }\n  getSuffix(code, count, options = {}) {\n    const rule = this.getRule(code, options);\n    if (rule) {\n      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${rule.select(count)}`;\n    }\n    this.logger.warn(`no plural rule found for: ${code}`);\n    return this.getSuffix('dev', count, options);\n  }\n}\n\nconst deepFindWithDefaults = (data, defaultData, key, keySeparator = '.', ignoreJSONStructure = true) => {\n  let path = getPathWithDefaults(data, defaultData, key);\n  if (!path && ignoreJSONStructure && isString(key)) {\n    path = deepFind(data, key, keySeparator);\n    if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n  }\n  return path;\n};\nconst regexSafe = val => val.replace(/\\$/g, '$$$$');\nclass Interpolator {\n  constructor(options = {}) {\n    this.logger = baseLogger.create('interpolator');\n    this.options = options;\n    this.format = options?.interpolation?.format || (value => value);\n    this.init(options);\n  }\n  init(options = {}) {\n    if (!options.interpolation) options.interpolation = {\n      escapeValue: true\n    };\n    const {\n      escape: escape$1,\n      escapeValue,\n      useRawValueToEscape,\n      prefix,\n      prefixEscaped,\n      suffix,\n      suffixEscaped,\n      formatSeparator,\n      unescapeSuffix,\n      unescapePrefix,\n      nestingPrefix,\n      nestingPrefixEscaped,\n      nestingSuffix,\n      nestingSuffixEscaped,\n      nestingOptionsSeparator,\n      maxReplaces,\n      alwaysFormat\n    } = options.interpolation;\n    this.escape = escape$1 !== undefined ? escape$1 : escape;\n    this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n    this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || '{{';\n    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || '}}';\n    this.formatSeparator = formatSeparator || ',';\n    this.unescapePrefix = unescapeSuffix ? '' : unescapePrefix || '-';\n    this.unescapeSuffix = this.unescapePrefix ? '' : unescapeSuffix || '';\n    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape('$t(');\n    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(')');\n    this.nestingOptionsSeparator = nestingOptionsSeparator || ',';\n    this.maxReplaces = maxReplaces || 1000;\n    this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n    this.resetRegExp();\n  }\n  reset() {\n    if (this.options) this.init(this.options);\n  }\n  resetRegExp() {\n    const getOrResetRegExp = (existingRegExp, pattern) => {\n      if (existingRegExp?.source === pattern) {\n        existingRegExp.lastIndex = 0;\n        return existingRegExp;\n      }\n      return new RegExp(pattern, 'g');\n    };\n    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()\"']+|\"[^\"]*\"|'[^']*'|\\\\((?:[^()]|\"[^\"]*\"|'[^']*')*\\\\))*?)${this.nestingSuffix}`);\n  }\n  interpolate(str, data, lng, options) {\n    let match;\n    let value;\n    let replaces;\n    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n    const handleFormat = key => {\n      if (key.indexOf(this.formatSeparator) < 0) {\n        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n        return this.alwaysFormat ? this.format(path, undefined, lng, {\n          ...options,\n          ...data,\n          interpolationkey: key\n        }) : path;\n      }\n      const p = key.split(this.formatSeparator);\n      const k = p.shift().trim();\n      const f = p.join(this.formatSeparator).trim();\n      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n        ...options,\n        ...data,\n        interpolationkey: k\n      });\n    };\n    this.resetRegExp();\n    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;\n    const skipOnVariables = options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n    const todos = [{\n      regex: this.regexpUnescape,\n      safeValue: val => regexSafe(val)\n    }, {\n      regex: this.regexp,\n      safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n    }];\n    todos.forEach(todo => {\n      replaces = 0;\n      while (match = todo.regex.exec(str)) {\n        const matchedVar = match[1].trim();\n        value = handleFormat(matchedVar);\n        if (value === undefined) {\n          if (typeof missingInterpolationHandler === 'function') {\n            const temp = missingInterpolationHandler(str, match, options);\n            value = isString(temp) ? temp : '';\n          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n            value = '';\n          } else if (skipOnVariables) {\n            value = match[0];\n            continue;\n          } else {\n            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n            value = '';\n          }\n        } else if (!isString(value) && !this.useRawValueToEscape) {\n          value = makeString(value);\n        }\n        const safeValue = todo.safeValue(value);\n        str = str.replace(match[0], safeValue);\n        if (skipOnVariables) {\n          todo.regex.lastIndex += value.length;\n          todo.regex.lastIndex -= match[0].length;\n        } else {\n          todo.regex.lastIndex = 0;\n        }\n        replaces++;\n        if (replaces >= this.maxReplaces) {\n          break;\n        }\n      }\n    });\n    return str;\n  }\n  nest(str, fc, options = {}) {\n    let match;\n    let value;\n    let clonedOptions;\n    const handleHasOptions = (key, inheritedOptions) => {\n      const sep = this.nestingOptionsSeparator;\n      if (key.indexOf(sep) < 0) return key;\n      const c = key.split(new RegExp(`${sep}[ ]*{`));\n      let optionsString = `{${c[1]}`;\n      key = c[0];\n      optionsString = this.interpolate(optionsString, clonedOptions);\n      const matchedSingleQuotes = optionsString.match(/'/g);\n      const matchedDoubleQuotes = optionsString.match(/\"/g);\n      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n        optionsString = optionsString.replace(/'/g, '\"');\n      }\n      try {\n        clonedOptions = JSON.parse(optionsString);\n        if (inheritedOptions) clonedOptions = {\n          ...inheritedOptions,\n          ...clonedOptions\n        };\n      } catch (e) {\n        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n        return `${key}${sep}${optionsString}`;\n      }\n      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n      return key;\n    };\n    while (match = this.nestingRegexp.exec(str)) {\n      let formatters = [];\n      clonedOptions = {\n        ...options\n      };\n      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;\n      clonedOptions.applyPostProcessor = false;\n      delete clonedOptions.defaultValue;\n      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf('}') + 1 : match[1].indexOf(this.formatSeparator);\n      if (keyEndIndex !== -1) {\n        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map(elem => elem.trim()).filter(Boolean);\n        match[1] = match[1].slice(0, keyEndIndex);\n      }\n      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n      if (value && match[0] === str && !isString(value)) return value;\n      if (!isString(value)) value = makeString(value);\n      if (!value) {\n        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n        value = '';\n      }\n      if (formatters.length) {\n        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {\n          ...options,\n          interpolationkey: match[1].trim()\n        }), value.trim());\n      }\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n    }\n    return str;\n  }\n}\n\nconst parseFormatStr = formatStr => {\n  let formatName = formatStr.toLowerCase().trim();\n  const formatOptions = {};\n  if (formatStr.indexOf('(') > -1) {\n    const p = formatStr.split('(');\n    formatName = p[0].toLowerCase().trim();\n    const optStr = p[1].substring(0, p[1].length - 1);\n    if (formatName === 'currency' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.range) formatOptions.range = optStr.trim();\n    } else {\n      const opts = optStr.split(';');\n      opts.forEach(opt => {\n        if (opt) {\n          const [key, ...rest] = opt.split(':');\n          const val = rest.join(':').trim().replace(/^'+|'+$/g, '');\n          const trimmedKey = key.trim();\n          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n          if (val === 'false') formatOptions[trimmedKey] = false;\n          if (val === 'true') formatOptions[trimmedKey] = true;\n          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n        }\n      });\n    }\n  }\n  return {\n    formatName,\n    formatOptions\n  };\n};\nconst createCachedFormatter = fn => {\n  const cache = {};\n  return (v, l, o) => {\n    let optForCache = o;\n    if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {\n      optForCache = {\n        ...optForCache,\n        [o.interpolationkey]: undefined\n      };\n    }\n    const key = l + JSON.stringify(optForCache);\n    let frm = cache[key];\n    if (!frm) {\n      frm = fn(getCleanedCode(l), o);\n      cache[key] = frm;\n    }\n    return frm(v);\n  };\n};\nconst createNonCachedFormatter = fn => (v, l, o) => fn(getCleanedCode(l), o)(v);\nclass Formatter {\n  constructor(options = {}) {\n    this.logger = baseLogger.create('formatter');\n    this.options = options;\n    this.init(options);\n  }\n  init(services, options = {\n    interpolation: {}\n  }) {\n    this.formatSeparator = options.interpolation.formatSeparator || ',';\n    const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;\n    this.formats = {\n      number: cf((lng, opt) => {\n        const formatter = new Intl.NumberFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      }),\n      currency: cf((lng, opt) => {\n        const formatter = new Intl.NumberFormat(lng, {\n          ...opt,\n          style: 'currency'\n        });\n        return val => formatter.format(val);\n      }),\n      datetime: cf((lng, opt) => {\n        const formatter = new Intl.DateTimeFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      }),\n      relativetime: cf((lng, opt) => {\n        const formatter = new Intl.RelativeTimeFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val, opt.range || 'day');\n      }),\n      list: cf((lng, opt) => {\n        const formatter = new Intl.ListFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      })\n    };\n  }\n  add(name, fc) {\n    this.formats[name.toLowerCase().trim()] = fc;\n  }\n  addCached(name, fc) {\n    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n  }\n  format(value, format, lng, options = {}) {\n    const formats = format.split(this.formatSeparator);\n    if (formats.length > 1 && formats[0].indexOf('(') > 1 && formats[0].indexOf(')') < 0 && formats.find(f => f.indexOf(')') > -1)) {\n      const lastIndex = formats.findIndex(f => f.indexOf(')') > -1);\n      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);\n    }\n    const result = formats.reduce((mem, f) => {\n      const {\n        formatName,\n        formatOptions\n      } = parseFormatStr(f);\n      if (this.formats[formatName]) {\n        let formatted = mem;\n        try {\n          const valOptions = options?.formatParams?.[options.interpolationkey] || {};\n          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n          formatted = this.formats[formatName](mem, l, {\n            ...formatOptions,\n            ...options,\n            ...valOptions\n          });\n        } catch (error) {\n          this.logger.warn(error);\n        }\n        return formatted;\n      } else {\n        this.logger.warn(`there was no format function for ${formatName}`);\n      }\n      return mem;\n    }, value);\n    return result;\n  }\n}\n\nconst removePending = (q, name) => {\n  if (q.pending[name] !== undefined) {\n    delete q.pending[name];\n    q.pendingCount--;\n  }\n};\nclass Connector extends EventEmitter {\n  constructor(backend, store, services, options = {}) {\n    super();\n    this.backend = backend;\n    this.store = store;\n    this.services = services;\n    this.languageUtils = services.languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('backendConnector');\n    this.waitingReads = [];\n    this.maxParallelReads = options.maxParallelReads || 10;\n    this.readingCalls = 0;\n    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n    this.state = {};\n    this.queue = [];\n    this.backend?.init?.(services, options.backend, options);\n  }\n  queueLoad(languages, namespaces, options, callback) {\n    const toLoad = {};\n    const pending = {};\n    const toLoadLanguages = {};\n    const toLoadNamespaces = {};\n    languages.forEach(lng => {\n      let hasAllNamespaces = true;\n      namespaces.forEach(ns => {\n        const name = `${lng}|${ns}`;\n        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n          this.state[name] = 2;\n        } else if (this.state[name] < 0) ; else if (this.state[name] === 1) {\n          if (pending[name] === undefined) pending[name] = true;\n        } else {\n          this.state[name] = 1;\n          hasAllNamespaces = false;\n          if (pending[name] === undefined) pending[name] = true;\n          if (toLoad[name] === undefined) toLoad[name] = true;\n          if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n        }\n      });\n      if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n    });\n    if (Object.keys(toLoad).length || Object.keys(pending).length) {\n      this.queue.push({\n        pending,\n        pendingCount: Object.keys(pending).length,\n        loaded: {},\n        errors: [],\n        callback\n      });\n    }\n    return {\n      toLoad: Object.keys(toLoad),\n      pending: Object.keys(pending),\n      toLoadLanguages: Object.keys(toLoadLanguages),\n      toLoadNamespaces: Object.keys(toLoadNamespaces)\n    };\n  }\n  loaded(name, err, data) {\n    const s = name.split('|');\n    const lng = s[0];\n    const ns = s[1];\n    if (err) this.emit('failedLoading', lng, ns, err);\n    if (!err && data) {\n      this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n        skipCopy: true\n      });\n    }\n    this.state[name] = err ? -1 : 2;\n    if (err && data) this.state[name] = 0;\n    const loaded = {};\n    this.queue.forEach(q => {\n      pushPath(q.loaded, [lng], ns);\n      removePending(q, name);\n      if (err) q.errors.push(err);\n      if (q.pendingCount === 0 && !q.done) {\n        Object.keys(q.loaded).forEach(l => {\n          if (!loaded[l]) loaded[l] = {};\n          const loadedKeys = q.loaded[l];\n          if (loadedKeys.length) {\n            loadedKeys.forEach(n => {\n              if (loaded[l][n] === undefined) loaded[l][n] = true;\n            });\n          }\n        });\n        q.done = true;\n        if (q.errors.length) {\n          q.callback(q.errors);\n        } else {\n          q.callback();\n        }\n      }\n    });\n    this.emit('loaded', loaded);\n    this.queue = this.queue.filter(q => !q.done);\n  }\n  read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {\n    if (!lng.length) return callback(null, {});\n    if (this.readingCalls >= this.maxParallelReads) {\n      this.waitingReads.push({\n        lng,\n        ns,\n        fcName,\n        tried,\n        wait,\n        callback\n      });\n      return;\n    }\n    this.readingCalls++;\n    const resolver = (err, data) => {\n      this.readingCalls--;\n      if (this.waitingReads.length > 0) {\n        const next = this.waitingReads.shift();\n        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n      }\n      if (err && data && tried < this.maxRetries) {\n        setTimeout(() => {\n          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n        }, wait);\n        return;\n      }\n      callback(err, data);\n    };\n    const fc = this.backend[fcName].bind(this.backend);\n    if (fc.length === 2) {\n      try {\n        const r = fc(lng, ns);\n        if (r && typeof r.then === 'function') {\n          r.then(data => resolver(null, data)).catch(resolver);\n        } else {\n          resolver(null, r);\n        }\n      } catch (err) {\n        resolver(err);\n      }\n      return;\n    }\n    return fc(lng, ns, resolver);\n  }\n  prepareLoading(languages, namespaces, options = {}, callback) {\n    if (!this.backend) {\n      this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n      return callback && callback();\n    }\n    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);\n    if (isString(namespaces)) namespaces = [namespaces];\n    const toLoad = this.queueLoad(languages, namespaces, options, callback);\n    if (!toLoad.toLoad.length) {\n      if (!toLoad.pending.length) callback();\n      return null;\n    }\n    toLoad.toLoad.forEach(name => {\n      this.loadOne(name);\n    });\n  }\n  load(languages, namespaces, callback) {\n    this.prepareLoading(languages, namespaces, {}, callback);\n  }\n  reload(languages, namespaces, callback) {\n    this.prepareLoading(languages, namespaces, {\n      reload: true\n    }, callback);\n  }\n  loadOne(name, prefix = '') {\n    const s = name.split('|');\n    const lng = s[0];\n    const ns = s[1];\n    this.read(lng, ns, 'read', undefined, undefined, (err, data) => {\n      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n      this.loaded(name, err, data);\n    });\n  }\n  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {}) {\n    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {\n      this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n      return;\n    }\n    if (key === undefined || key === null || key === '') return;\n    if (this.backend?.create) {\n      const opts = {\n        ...options,\n        isUpdate\n      };\n      const fc = this.backend.create.bind(this.backend);\n      if (fc.length < 6) {\n        try {\n          let r;\n          if (fc.length === 5) {\n            r = fc(languages, namespace, key, fallbackValue, opts);\n          } else {\n            r = fc(languages, namespace, key, fallbackValue);\n          }\n          if (r && typeof r.then === 'function') {\n            r.then(data => clb(null, data)).catch(clb);\n          } else {\n            clb(null, r);\n          }\n        } catch (err) {\n          clb(err);\n        }\n      } else {\n        fc(languages, namespace, key, fallbackValue, clb, opts);\n      }\n    }\n    if (!languages || !languages[0]) return;\n    this.store.addResource(languages[0], namespace, key, fallbackValue);\n  }\n}\n\nconst get = () => ({\n  debug: false,\n  initAsync: true,\n  ns: ['translation'],\n  defaultNS: ['translation'],\n  fallbackLng: ['dev'],\n  fallbackNS: false,\n  supportedLngs: false,\n  nonExplicitSupportedLngs: false,\n  load: 'all',\n  preload: false,\n  simplifyPluralSuffix: true,\n  keySeparator: '.',\n  nsSeparator: ':',\n  pluralSeparator: '_',\n  contextSeparator: '_',\n  partialBundledLanguages: false,\n  saveMissing: false,\n  updateMissing: false,\n  saveMissingTo: 'fallback',\n  saveMissingPlurals: true,\n  missingKeyHandler: false,\n  missingInterpolationHandler: false,\n  postProcess: false,\n  postProcessPassResolved: false,\n  returnNull: false,\n  returnEmptyString: true,\n  returnObjects: false,\n  joinArrays: false,\n  returnedObjectHandler: false,\n  parseMissingKeyHandler: false,\n  appendNamespaceToMissingKey: false,\n  appendNamespaceToCIMode: false,\n  overloadTranslationOptionHandler: args => {\n    let ret = {};\n    if (typeof args[1] === 'object') ret = args[1];\n    if (isString(args[1])) ret.defaultValue = args[1];\n    if (isString(args[2])) ret.tDescription = args[2];\n    if (typeof args[2] === 'object' || typeof args[3] === 'object') {\n      const options = args[3] || args[2];\n      Object.keys(options).forEach(key => {\n        ret[key] = options[key];\n      });\n    }\n    return ret;\n  },\n  interpolation: {\n    escapeValue: true,\n    format: value => value,\n    prefix: '{{',\n    suffix: '}}',\n    formatSeparator: ',',\n    unescapePrefix: '-',\n    nestingPrefix: '$t(',\n    nestingSuffix: ')',\n    nestingOptionsSeparator: ',',\n    maxReplaces: 1000,\n    skipOnVariables: true\n  },\n  cacheInBuiltFormats: true\n});\nconst transformOptions = options => {\n  if (isString(options.ns)) options.ns = [options.ns];\n  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];\n  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];\n  if (options.supportedLngs?.indexOf?.('cimode') < 0) {\n    options.supportedLngs = options.supportedLngs.concat(['cimode']);\n  }\n  if (typeof options.initImmediate === 'boolean') options.initAsync = options.initImmediate;\n  return options;\n};\n\nconst noop = () => {};\nconst bindMemberFunctions = inst => {\n  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n  mems.forEach(mem => {\n    if (typeof inst[mem] === 'function') {\n      inst[mem] = inst[mem].bind(inst);\n    }\n  });\n};\nclass I18n extends EventEmitter {\n  constructor(options = {}, callback) {\n    super();\n    this.options = transformOptions(options);\n    this.services = {};\n    this.logger = baseLogger;\n    this.modules = {\n      external: []\n    };\n    bindMemberFunctions(this);\n    if (callback && !this.isInitialized && !options.isClone) {\n      if (!this.options.initAsync) {\n        this.init(options, callback);\n        return this;\n      }\n      setTimeout(() => {\n        this.init(options, callback);\n      }, 0);\n    }\n  }\n  init(options = {}, callback) {\n    this.isInitializing = true;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (options.defaultNS == null && options.ns) {\n      if (isString(options.ns)) {\n        options.defaultNS = options.ns;\n      } else if (options.ns.indexOf('translation') < 0) {\n        options.defaultNS = options.ns[0];\n      }\n    }\n    const defOpts = get();\n    this.options = {\n      ...defOpts,\n      ...this.options,\n      ...transformOptions(options)\n    };\n    this.options.interpolation = {\n      ...defOpts.interpolation,\n      ...this.options.interpolation\n    };\n    if (options.keySeparator !== undefined) {\n      this.options.userDefinedKeySeparator = options.keySeparator;\n    }\n    if (options.nsSeparator !== undefined) {\n      this.options.userDefinedNsSeparator = options.nsSeparator;\n    }\n    const createClassOnDemand = ClassOrObject => {\n      if (!ClassOrObject) return null;\n      if (typeof ClassOrObject === 'function') return new ClassOrObject();\n      return ClassOrObject;\n    };\n    if (!this.options.isClone) {\n      if (this.modules.logger) {\n        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n      } else {\n        baseLogger.init(null, this.options);\n      }\n      let formatter;\n      if (this.modules.formatter) {\n        formatter = this.modules.formatter;\n      } else {\n        formatter = Formatter;\n      }\n      const lu = new LanguageUtil(this.options);\n      this.store = new ResourceStore(this.options.resources, this.options);\n      const s = this.services;\n      s.logger = baseLogger;\n      s.resourceStore = this.store;\n      s.languageUtils = lu;\n      s.pluralResolver = new PluralResolver(lu, {\n        prepend: this.options.pluralSeparator,\n        simplifyPluralSuffix: this.options.simplifyPluralSuffix\n      });\n      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;\n      if (usingLegacyFormatFunction) {\n        this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);\n      }\n      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n        s.formatter = createClassOnDemand(formatter);\n        if (s.formatter.init) s.formatter.init(s, this.options);\n        this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n      }\n      s.interpolator = new Interpolator(this.options);\n      s.utils = {\n        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n      };\n      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n      s.backendConnector.on('*', (event, ...args) => {\n        this.emit(event, ...args);\n      });\n      if (this.modules.languageDetector) {\n        s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n      }\n      if (this.modules.i18nFormat) {\n        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n        if (s.i18nFormat.init) s.i18nFormat.init(this);\n      }\n      this.translator = new Translator(this.services, this.options);\n      this.translator.on('*', (event, ...args) => {\n        this.emit(event, ...args);\n      });\n      this.modules.external.forEach(m => {\n        if (m.init) m.init(this);\n      });\n    }\n    this.format = this.options.interpolation.format;\n    if (!callback) callback = noop;\n    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n      if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n    }\n    if (!this.services.languageDetector && !this.options.lng) {\n      this.logger.warn('init: no languageDetector is used and no lng is defined');\n    }\n    const storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];\n    storeApi.forEach(fcName => {\n      this[fcName] = (...args) => this.store[fcName](...args);\n    });\n    const storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];\n    storeApiChained.forEach(fcName => {\n      this[fcName] = (...args) => {\n        this.store[fcName](...args);\n        return this;\n      };\n    });\n    const deferred = defer();\n    const load = () => {\n      const finish = (err, t) => {\n        this.isInitializing = false;\n        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');\n        this.isInitialized = true;\n        if (!this.options.isClone) this.logger.log('initialized', this.options);\n        this.emit('initialized', this.options);\n        deferred.resolve(t);\n        callback(err, t);\n      };\n      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));\n      this.changeLanguage(this.options.lng, finish);\n    };\n    if (this.options.resources || !this.options.initAsync) {\n      load();\n    } else {\n      setTimeout(load, 0);\n    }\n    return deferred;\n  }\n  loadResources(language, callback = noop) {\n    let usedCallback = callback;\n    const usedLng = isString(language) ? language : this.language;\n    if (typeof language === 'function') usedCallback = language;\n    if (!this.options.resources || this.options.partialBundledLanguages) {\n      if (usedLng?.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n      const toLoad = [];\n      const append = lng => {\n        if (!lng) return;\n        if (lng === 'cimode') return;\n        const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n        lngs.forEach(l => {\n          if (l === 'cimode') return;\n          if (toLoad.indexOf(l) < 0) toLoad.push(l);\n        });\n      };\n      if (!usedLng) {\n        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n        fallbacks.forEach(l => append(l));\n      } else {\n        append(usedLng);\n      }\n      this.options.preload?.forEach?.(l => append(l));\n      this.services.backendConnector.load(toLoad, this.options.ns, e => {\n        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n        usedCallback(e);\n      });\n    } else {\n      usedCallback(null);\n    }\n  }\n  reloadResources(lngs, ns, callback) {\n    const deferred = defer();\n    if (typeof lngs === 'function') {\n      callback = lngs;\n      lngs = undefined;\n    }\n    if (typeof ns === 'function') {\n      callback = ns;\n      ns = undefined;\n    }\n    if (!lngs) lngs = this.languages;\n    if (!ns) ns = this.options.ns;\n    if (!callback) callback = noop;\n    this.services.backendConnector.reload(lngs, ns, err => {\n      deferred.resolve();\n      callback(err);\n    });\n    return deferred;\n  }\n  use(module) {\n    if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n    if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n    if (module.type === 'backend') {\n      this.modules.backend = module;\n    }\n    if (module.type === 'logger' || module.log && module.warn && module.error) {\n      this.modules.logger = module;\n    }\n    if (module.type === 'languageDetector') {\n      this.modules.languageDetector = module;\n    }\n    if (module.type === 'i18nFormat') {\n      this.modules.i18nFormat = module;\n    }\n    if (module.type === 'postProcessor') {\n      postProcessor.addPostProcessor(module);\n    }\n    if (module.type === 'formatter') {\n      this.modules.formatter = module;\n    }\n    if (module.type === '3rdParty') {\n      this.modules.external.push(module);\n    }\n    return this;\n  }\n  setResolvedLanguage(l) {\n    if (!l || !this.languages) return;\n    if (['cimode', 'dev'].indexOf(l) > -1) return;\n    for (let li = 0; li < this.languages.length; li++) {\n      const lngInLngs = this.languages[li];\n      if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;\n      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n        this.resolvedLanguage = lngInLngs;\n        break;\n      }\n    }\n    if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {\n      this.resolvedLanguage = l;\n      this.languages.unshift(l);\n    }\n  }\n  changeLanguage(lng, callback) {\n    this.isLanguageChangingTo = lng;\n    const deferred = defer();\n    this.emit('languageChanging', lng);\n    const setLngProps = l => {\n      this.language = l;\n      this.languages = this.services.languageUtils.toResolveHierarchy(l);\n      this.resolvedLanguage = undefined;\n      this.setResolvedLanguage(l);\n    };\n    const done = (err, l) => {\n      if (l) {\n        if (this.isLanguageChangingTo === lng) {\n          setLngProps(l);\n          this.translator.changeLanguage(l);\n          this.isLanguageChangingTo = undefined;\n          this.emit('languageChanged', l);\n          this.logger.log('languageChanged', l);\n        }\n      } else {\n        this.isLanguageChangingTo = undefined;\n      }\n      deferred.resolve((...args) => this.t(...args));\n      if (callback) callback(err, (...args) => this.t(...args));\n    };\n    const setLng = lngs => {\n      if (!lng && !lngs && this.services.languageDetector) lngs = [];\n      const fl = isString(lngs) ? lngs : lngs && lngs[0];\n      const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [lngs] : lngs);\n      if (l) {\n        if (!this.language) {\n          setLngProps(l);\n        }\n        if (!this.translator.language) this.translator.changeLanguage(l);\n        this.services.languageDetector?.cacheUserLanguage?.(l);\n      }\n      this.loadResources(l, err => {\n        done(err, l);\n      });\n    };\n    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n      setLng(this.services.languageDetector.detect());\n    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n      if (this.services.languageDetector.detect.length === 0) {\n        this.services.languageDetector.detect().then(setLng);\n      } else {\n        this.services.languageDetector.detect(setLng);\n      }\n    } else {\n      setLng(lng);\n    }\n    return deferred;\n  }\n  getFixedT(lng, ns, keyPrefix) {\n    const fixedT = (key, opts, ...rest) => {\n      let o;\n      if (typeof opts !== 'object') {\n        o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));\n      } else {\n        o = {\n          ...opts\n        };\n      }\n      o.lng = o.lng || fixedT.lng;\n      o.lngs = o.lngs || fixedT.lngs;\n      o.ns = o.ns || fixedT.ns;\n      if (o.keyPrefix !== '') o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;\n      const keySeparator = this.options.keySeparator || '.';\n      let resultKey;\n      if (o.keyPrefix && Array.isArray(key)) {\n        resultKey = key.map(k => `${o.keyPrefix}${keySeparator}${k}`);\n      } else {\n        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;\n      }\n      return this.t(resultKey, o);\n    };\n    if (isString(lng)) {\n      fixedT.lng = lng;\n    } else {\n      fixedT.lngs = lng;\n    }\n    fixedT.ns = ns;\n    fixedT.keyPrefix = keyPrefix;\n    return fixedT;\n  }\n  t(...args) {\n    return this.translator?.translate(...args);\n  }\n  exists(...args) {\n    return this.translator?.exists(...args);\n  }\n  setDefaultNamespace(ns) {\n    this.options.defaultNS = ns;\n  }\n  hasLoadedNamespace(ns, options = {}) {\n    if (!this.isInitialized) {\n      this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n      return false;\n    }\n    if (!this.languages || !this.languages.length) {\n      this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n      return false;\n    }\n    const lng = options.lng || this.resolvedLanguage || this.languages[0];\n    const fallbackLng = this.options ? this.options.fallbackLng : false;\n    const lastLng = this.languages[this.languages.length - 1];\n    if (lng.toLowerCase() === 'cimode') return true;\n    const loadNotPending = (l, n) => {\n      const loadState = this.services.backendConnector.state[`${l}|${n}`];\n      return loadState === -1 || loadState === 0 || loadState === 2;\n    };\n    if (options.precheck) {\n      const preResult = options.precheck(this, loadNotPending);\n      if (preResult !== undefined) return preResult;\n    }\n    if (this.hasResourceBundle(lng, ns)) return true;\n    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n    return false;\n  }\n  loadNamespaces(ns, callback) {\n    const deferred = defer();\n    if (!this.options.ns) {\n      if (callback) callback();\n      return Promise.resolve();\n    }\n    if (isString(ns)) ns = [ns];\n    ns.forEach(n => {\n      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n    });\n    this.loadResources(err => {\n      deferred.resolve();\n      if (callback) callback(err);\n    });\n    return deferred;\n  }\n  loadLanguages(lngs, callback) {\n    const deferred = defer();\n    if (isString(lngs)) lngs = [lngs];\n    const preloaded = this.options.preload || [];\n    const newLngs = lngs.filter(lng => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n    if (!newLngs.length) {\n      if (callback) callback();\n      return Promise.resolve();\n    }\n    this.options.preload = preloaded.concat(newLngs);\n    this.loadResources(err => {\n      deferred.resolve();\n      if (callback) callback(err);\n    });\n    return deferred;\n  }\n  dir(lng) {\n    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);\n    if (!lng) return 'rtl';\n    try {\n      const l = new Intl.Locale(lng);\n      if (l && l.getTextInfo) {\n        const ti = l.getTextInfo();\n        if (ti && ti.direction) return ti.direction;\n      }\n    } catch (e) {}\n    const rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];\n    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());\n    if (lng.toLowerCase().indexOf('-latn') > 1) return 'ltr';\n    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';\n  }\n  static createInstance(options = {}, callback) {\n    return new I18n(options, callback);\n  }\n  cloneInstance(options = {}, callback = noop) {\n    const forkResourceStore = options.forkResourceStore;\n    if (forkResourceStore) delete options.forkResourceStore;\n    const mergedOptions = {\n      ...this.options,\n      ...options,\n      ...{\n        isClone: true\n      }\n    };\n    const clone = new I18n(mergedOptions);\n    if (options.debug !== undefined || options.prefix !== undefined) {\n      clone.logger = clone.logger.clone(options);\n    }\n    const membersToCopy = ['store', 'services', 'language'];\n    membersToCopy.forEach(m => {\n      clone[m] = this[m];\n    });\n    clone.services = {\n      ...this.services\n    };\n    clone.services.utils = {\n      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n    };\n    if (forkResourceStore) {\n      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {\n        prev[l] = {\n          ...this.store.data[l]\n        };\n        prev[l] = Object.keys(prev[l]).reduce((acc, n) => {\n          acc[n] = {\n            ...prev[l][n]\n          };\n          return acc;\n        }, prev[l]);\n        return prev;\n      }, {});\n      clone.store = new ResourceStore(clonedData, mergedOptions);\n      clone.services.resourceStore = clone.store;\n    }\n    clone.translator = new Translator(clone.services, mergedOptions);\n    clone.translator.on('*', (event, ...args) => {\n      clone.emit(event, ...args);\n    });\n    clone.init(mergedOptions, callback);\n    clone.translator.options = mergedOptions;\n    clone.translator.backendConnector.services.utils = {\n      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n    };\n    return clone;\n  }\n  toJSON() {\n    return {\n      options: this.options,\n      store: this.store,\n      language: this.language,\n      languages: this.languages,\n      resolvedLanguage: this.resolvedLanguage\n    };\n  }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\n\nmodule.exports = instance;\n\n\n//# sourceURL=webpack://startbootstrap-personal/./node_modules/i18next/dist/cjs/i18next.js?\n}");

/***/ }),

/***/ "./src/js/i18n.js":
/*!************************!*\
  !*** ./src/js/i18n.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.changeLanguage = changeLanguage;\nexports[\"default\"] = void 0;\nexports.getCurrentLanguage = getCurrentLanguage;\nexports.t = t;\nvar _i18next = _interopRequireDefault(__webpack_require__(/*! i18next */ \"./node_modules/i18next/dist/cjs/i18next.js\"));\nvar _i18nextBrowserLanguagedetector = _interopRequireDefault(__webpack_require__(/*! i18next-browser-languagedetector */ \"./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js\"));\nvar _translation = _interopRequireDefault(__webpack_require__(/*! ../locales/en/translation.json */ \"./src/locales/en/translation.json\"));\nvar _translation2 = _interopRequireDefault(__webpack_require__(/*! ../locales/es/translation.json */ \"./src/locales/es/translation.json\"));\nvar _translation3 = _interopRequireDefault(__webpack_require__(/*! ../locales/gl/translation.json */ \"./src/locales/gl/translation.json\"));\n// Translation files\n\nvar resources = {\n  en: {\n    translation: _translation[\"default\"]\n  },\n  es: {\n    translation: _translation2[\"default\"]\n  },\n  gl: {\n    translation: _translation3[\"default\"]\n  }\n};\n_i18next[\"default\"].use(_i18nextBrowserLanguagedetector[\"default\"]).init({\n  resources: resources,\n  fallbackLng: 'en',\n  lng: localStorage.getItem('selectedLanguage') || 'en',\n  debug: true,\n  detection: {\n    order: ['localStorage', 'navigator', 'htmlTag'],\n    caches: ['localStorage'],\n    lookupLocalStorage: 'selectedLanguage'\n  },\n  interpolation: {\n    escapeValue: false\n  }\n});\n\n// Function to translate text\nfunction t(key) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!_i18next[\"default\"].isInitialized) {\n    return key;\n  }\n  return _i18next[\"default\"].t(key, options);\n}\n\n// Function to change language\nfunction changeLanguage(lng) {\n  console.log('changeLanguage called with:', lng);\n  return new Promise(function (resolve) {\n    _i18next[\"default\"].changeLanguage(lng, function (err, t) {\n      console.log('i18next.changeLanguage callback - err:', err, 'language:', lng);\n      if (!err) {\n        localStorage.setItem('selectedLanguage', lng);\n        updatePageContent();\n        updateHtmlLang(lng);\n        console.log('Language change completed successfully');\n      } else {\n        console.error('Error changing language:', err);\n      }\n      resolve(t);\n    });\n  });\n}\n\n// Function to get current language\nfunction getCurrentLanguage() {\n  return _i18next[\"default\"].language;\n}\n\n// Function to update HTML lang attribute\nfunction updateHtmlLang(lng) {\n  document.documentElement.setAttribute('lang', lng);\n}\n\n// Function to update all translatable content on the page\nfunction updatePageContent() {\n  console.log('updatePageContent called');\n  // Update meta tags\n  document.title = t('meta.title');\n  var metaDescription = document.querySelector('meta[name=\"description\"]');\n  if (metaDescription) {\n    metaDescription.setAttribute('content', t('meta.description'));\n  }\n\n  // Update all elements with data-i18n attribute\n  var elements = document.querySelectorAll('[data-i18n]');\n  console.log('Found elements to translate:', elements.length);\n  elements.forEach(function (element) {\n    var key = element.getAttribute('data-i18n');\n    var translation = t(key);\n    console.log('Translating', key, 'to:', translation);\n    if (element.tagName === 'INPUT' && (element.type === 'submit' || element.type === 'button')) {\n      element.value = translation;\n    } else if (element.hasAttribute('placeholder')) {\n      element.placeholder = translation;\n    } else if (element.hasAttribute('title')) {\n      element.title = translation;\n    } else if (element.hasAttribute('aria-label')) {\n      element.setAttribute('aria-label', translation);\n    } else {\n      element.innerHTML = translation;\n    }\n  });\n\n  // Update CV download links to use language-specific CV\n  var currentLang = getCurrentLanguage();\n  var cvLinks = document.querySelectorAll('a[href*=\"CV_FIZREYARMESTO\"]');\n  cvLinks.forEach(function (link) {\n    var cvFile = 'assets/CV_FIZREYARMESTO_ENG.pdf';\n    if (currentLang === 'es') {\n      cvFile = 'assets/CV_FIZREYARMESTO_ES.pdf';\n    } else if (currentLang === 'gl') {\n      cvFile = 'assets/CV_FIZREYARMESTO_GL.pdf';\n    }\n    link.href = cvFile;\n  });\n}\n\n// Initialize content on page load\ndocument.addEventListener('DOMContentLoaded', function () {\n  console.log('i18n DOMContentLoaded event fired');\n  // Wait for i18next to be ready\n  _i18next[\"default\"].on('initialized', function () {\n    console.log('i18next initialized event fired');\n    updatePageContent();\n    updateHtmlLang(getCurrentLanguage());\n  });\n\n  // If already initialized, update immediately\n  if (_i18next[\"default\"].isInitialized) {\n    console.log('i18next already initialized');\n    updatePageContent();\n    updateHtmlLang(getCurrentLanguage());\n  }\n});\nconsole.log('i18n.js module loaded');\n\n// Listen for language changes\n_i18next[\"default\"].on('languageChanged', function (lng) {\n  updatePageContent();\n  updateHtmlLang(lng);\n});\nvar _default = exports[\"default\"] = _i18next[\"default\"];\n\n//# sourceURL=webpack://startbootstrap-personal/./src/js/i18n.js?\n}");

/***/ }),

/***/ "./src/js/scripts.js":
/*!***************************!*\
  !*** ./src/js/scripts.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nvar _i18n = __webpack_require__(/*! ./i18n.js */ \"./src/js/i18n.js\");\n// Import i18n functionality\n\nconsole.log('Scripts.js loaded');\n\n// Wait for DOM to be ready\ndocument.addEventListener('DOMContentLoaded', function () {\n  console.log('DOM loaded, initializing components');\n  console.log('=== STARTING COMPONENT INITIALIZATION ===');\n\n  // Initialize language switcher\n  initializeLanguageSwitcher();\n  console.log('=== LANGUAGE SWITCHER INITIALIZED ===');\n\n  // Initialize theme switcher\n  initializeThemeSwitcher();\n  console.log('=== THEME SWITCHER INITIALIZED ===');\n\n  // Initialize project interactions\n  initializeProjectInteractions();\n  console.log('=== PROJECT INTERACTIONS INITIALIZED ===');\n\n  // Test setTimeout first\n  setTimeout(function () {\n    console.log('TEST: setTimeout is working!');\n  }, 50);\n\n  // Initialize Pong game with a small delay to ensure DOM is ready\n  setTimeout(function () {\n    console.log('Attempting to initialize Pong game...');\n    initializePongGame();\n  }, 100);\n\n  // Also try immediate initialization\n  console.log('Attempting immediate Pong game initialization...');\n  initializePongGame();\n  console.log('=== END OF DOMCONTENTLOADED HANDLER ===');\n});\nfunction initializeLanguageSwitcher() {\n  console.log('Initializing language switcher');\n\n  // Find all language links\n  var languageLinks = document.querySelectorAll('[data-lang]');\n  console.log('Found language links:', languageLinks.length);\n\n  // Add click event listeners to language links\n  languageLinks.forEach(function (link) {\n    link.addEventListener('click', function (e) {\n      e.preventDefault();\n      console.log('Language link clicked');\n      var selectedLang = this.getAttribute('data-lang');\n      console.log('Selected language:', selectedLang);\n\n      // Change language\n      (0, _i18n.changeLanguage)(selectedLang).then(function () {\n        console.log('Language changed successfully to:', selectedLang);\n        updateActiveLanguage(selectedLang);\n      })[\"catch\"](function (error) {\n        console.error('Error changing language:', error);\n      });\n    });\n  });\n\n  // Set initial active language\n  var currentLang = (0, _i18n.getCurrentLanguage)();\n  console.log('Current language:', currentLang);\n  updateActiveLanguage(currentLang);\n}\nfunction updateActiveLanguage(lang) {\n  console.log('Updating active language to:', lang);\n  var languageLinks = document.querySelectorAll('[data-lang]');\n  languageLinks.forEach(function (link) {\n    link.classList.remove('active');\n    if (link.getAttribute('data-lang') === lang) {\n      link.classList.add('active');\n    }\n  });\n}\nfunction initializeThemeSwitcher() {\n  console.log('Initializing theme switcher');\n\n  // Get theme toggle button\n  var themeToggle = document.querySelector('.theme-toggle');\n  var themeIcon = document.querySelector('.theme-icon');\n  var themeText = document.querySelector('.theme-text');\n  if (!themeToggle) {\n    console.warn('Theme toggle button not found');\n    return;\n  }\n\n  // Load saved theme or default to light\n  var savedTheme = localStorage.getItem('theme') || 'light';\n  console.log('Loaded saved theme:', savedTheme);\n  setTheme(savedTheme);\n\n  // Add click event listener\n  themeToggle.addEventListener('click', function () {\n    console.log('Theme toggle clicked');\n    var currentTheme = document.documentElement.getAttribute('data-theme') || 'light';\n    var newTheme = currentTheme === 'light' ? 'dark' : 'light';\n    console.log('Switching from', currentTheme, 'to', newTheme);\n    setTheme(newTheme);\n    localStorage.setItem('theme', newTheme);\n  });\n}\nfunction setTheme(theme) {\n  console.log('Setting theme to:', theme);\n  var themeIcon = document.querySelector('.theme-icon');\n  var themeText = document.querySelector('.theme-text');\n  if (theme === 'dark') {\n    document.documentElement.setAttribute('data-theme', 'dark');\n    if (themeIcon) {\n      themeIcon.className = 'theme-icon bi bi-sun-fill';\n    }\n    if (themeText) {\n      themeText.setAttribute('data-i18n', 'nav.lightMode');\n      themeText.textContent = (0, _i18n.t)('nav.lightMode');\n    }\n  } else {\n    document.documentElement.setAttribute('data-theme', 'light');\n    if (themeIcon) {\n      themeIcon.className = 'theme-icon bi bi-moon-fill';\n    }\n    if (themeText) {\n      themeText.setAttribute('data-i18n', 'nav.darkMode');\n      themeText.textContent = (0, _i18n.t)('nav.darkMode');\n    }\n  }\n}\nfunction initializeProjectInteractions() {\n  console.log('Initializing project interactions');\n\n  // Add special interactions for different project types\n  var projectCards = document.querySelectorAll('.project-card');\n  projectCards.forEach(function (card) {\n    var projectType = card.getAttribute('data-project');\n\n    // Add hover sound effects (optional)\n    card.addEventListener('mouseenter', function () {\n      this.classList.add('project-hovered');\n    });\n    card.addEventListener('mouseleave', function () {\n      this.classList.remove('project-hovered');\n    });\n\n    // Special handling for specific projects\n    switch (projectType) {\n      case 'yabs':\n        // Already has modal functionality\n        break;\n      case 'eyeflow':\n        // Add video preview functionality for Eyeflow\n        addVideoPreview(card);\n        break;\n      case 'noche':\n        // Add video preview functionality\n        addVideoPreview(card);\n        break;\n      case 'beeShowcase':\n        // Add video preview functionality for Miel 79\n        addVideoPreview(card);\n        break;\n      case 'renfeSimulator':\n        // Add video preview functionality for railway simulator\n        addVideoPreview(card);\n        break;\n      case 'vrsurvival':\n        // Could add video preview functionality here\n        addVideoPreview(card);\n        break;\n      case 'customEditor':\n      case 'endlessRunner':\n        // Could add image gallery functionality here\n        addImageGallery(card);\n        break;\n      default:\n        // Default hover effects\n        break;\n    }\n  });\n}\nfunction addVideoPreview(card) {\n  var videoId = card.getAttribute('data-video');\n  var overlay = card.querySelector('.project-overlay');\n  var videoContainer = card.querySelector('.video-container');\n  var iframe = card.querySelector('.video-container iframe');\n  var closeButton = card.querySelector('.video-close');\n  if (overlay && videoId) {\n    // Function to hide video\n    var hideVideo = function hideVideo() {\n      iframe.src = '';\n      card.classList.remove('video-playing');\n      videoContainer.style.display = 'none';\n    };\n\n    // Show video on overlay click\n    overlay.addEventListener('click', function (e) {\n      e.preventDefault();\n      console.log('Video preview clicked for:', card.getAttribute('data-project'));\n      if (videoContainer && iframe) {\n        // Set the YouTube embed URL\n        var embedUrl = \"https://www.youtube.com/embed/\".concat(videoId, \"?autoplay=1&mute=1&rel=0&modestbranding=1\");\n        iframe.src = embedUrl;\n\n        // Show video and hide overlay\n        card.classList.add('video-playing');\n        videoContainer.style.display = 'block';\n\n        // Hide video when clicking outside or on escape\n        var handleOutsideClick = function handleOutsideClick(event) {\n          if (!card.contains(event.target)) {\n            hideVideo();\n            document.removeEventListener('click', handleOutsideClick);\n            document.removeEventListener('keydown', handleEscapeKey);\n          }\n        };\n\n        // Hide video on escape key\n        var handleEscapeKey = function handleEscapeKey(event) {\n          if (event.key === 'Escape') {\n            hideVideo();\n            document.removeEventListener('click', handleOutsideClick);\n            document.removeEventListener('keydown', handleEscapeKey);\n          }\n        };\n\n        // Add event listeners after a short delay to prevent immediate hiding\n        setTimeout(function () {\n          document.addEventListener('click', handleOutsideClick);\n          document.addEventListener('keydown', handleEscapeKey);\n        }, 100);\n      }\n    });\n\n    // Handle close button click\n    if (closeButton) {\n      closeButton.addEventListener('click', function (e) {\n        e.stopPropagation();\n        hideVideo();\n      });\n    }\n\n    // Add hover effect for video projects\n    if (card.classList.contains('video-project')) {\n      card.addEventListener('mouseenter', function () {\n        var overlayContent = overlay.querySelector('.overlay-content p');\n        if (overlayContent && !card.classList.contains('video-playing')) {\n          overlayContent.textContent = 'Click to Watch';\n        }\n      });\n      card.addEventListener('mouseleave', function () {\n        var overlayContent = overlay.querySelector('.overlay-content p');\n        if (overlayContent && !card.classList.contains('video-playing')) {\n          overlayContent.textContent = 'Click to Watch'; // Keep \"Click to Watch\" instead of reverting\n        }\n      });\n    }\n  }\n}\nfunction addImageGallery(card) {\n  // Placeholder for image gallery functionality\n  // This could cycle through multiple project images\n  var overlay = card.querySelector('.project-overlay');\n  if (overlay) {\n    overlay.addEventListener('click', function (e) {\n      e.preventDefault();\n      console.log('Image gallery would open here for:', card.getAttribute('data-project'));\n      // Future implementation: open image gallery modal\n    });\n  }\n}\n\n// Smooth scrolling for navigation links\ndocument.addEventListener('click', function (e) {\n  if (e.target.matches('a[href^=\"#\"]')) {\n    e.preventDefault();\n    var targetId = e.target.getAttribute('href').substring(1);\n    var targetElement = document.getElementById(targetId);\n    if (targetElement) {\n      targetElement.scrollIntoView({\n        behavior: 'smooth',\n        block: 'start'\n      });\n    }\n  }\n});\n\n// Initialize fullscreen functionality for Unity games\ndocument.addEventListener('DOMContentLoaded', function () {\n  // YABS fullscreen button\n  var yabsFullscreenBtn = document.getElementById('yabsFullscreenBtn');\n  if (yabsFullscreenBtn) {\n    yabsFullscreenBtn.addEventListener('click', function () {\n      var yabsFrame = document.getElementById('yabsFrame');\n      if (yabsFrame && yabsFrame.src) {\n        // Send message to iframe to trigger fullscreen\n        yabsFrame.contentWindow.postMessage('toggleFullscreen', '*');\n      }\n    });\n  }\n\n  // Shinjuku-eki fullscreen button\n  var shinjukuEkiFullscreenBtn = document.getElementById('shinjukuEkiFullscreenBtn');\n  if (shinjukuEkiFullscreenBtn) {\n    shinjukuEkiFullscreenBtn.addEventListener('click', function () {\n      var shinjukuEkiFrame = document.getElementById('shinjukuEkiFrame');\n      if (shinjukuEkiFrame && shinjukuEkiFrame.src) {\n        // Send message to iframe to trigger fullscreen\n        shinjukuEkiFrame.contentWindow.postMessage('toggleFullscreen', '*');\n      }\n    });\n  }\n\n  // Listen for messages from Unity iframes to update button icons\n  window.addEventListener('message', function (event) {\n    if (event.data === 'enteredFullscreen') {\n      // Update button icons to exit fullscreen\n      var yabsBtn = document.getElementById('yabsFullscreenBtn');\n      var shinjukuBtn = document.getElementById('shinjukuEkiFullscreenBtn');\n      if (yabsBtn) {\n        yabsBtn.innerHTML = '<i class=\"bi bi-fullscreen-exit\"></i>';\n        yabsBtn.title = 'Exit Fullscreen';\n      }\n      if (shinjukuBtn) {\n        shinjukuBtn.innerHTML = '<i class=\"bi bi-fullscreen-exit\"></i>';\n        shinjukuBtn.title = 'Exit Fullscreen';\n      }\n    } else if (event.data === 'exitedFullscreen') {\n      // Update button icons to enter fullscreen\n      var _yabsBtn = document.getElementById('yabsFullscreenBtn');\n      var _shinjukuBtn = document.getElementById('shinjukuEkiFullscreenBtn');\n      if (_yabsBtn) {\n        _yabsBtn.innerHTML = '<i class=\"bi bi-fullscreen\"></i>';\n        _yabsBtn.title = 'Fullscreen';\n      }\n      if (_shinjukuBtn) {\n        _shinjukuBtn.innerHTML = '<i class=\"bi bi-fullscreen\"></i>';\n        _shinjukuBtn.title = 'Fullscreen';\n      }\n    }\n  });\n});\n\n// Add scroll-triggered animations for project cards\nvar observerOptions = {\n  threshold: 0.1,\n  rootMargin: '0px 0px -50px 0px'\n};\nvar projectObserver = new IntersectionObserver(function (entries) {\n  entries.forEach(function (entry) {\n    if (entry.isIntersecting) {\n      entry.target.classList.add('project-visible');\n    }\n  });\n}, observerOptions);\n\n// Observe project cards when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function () {\n  var projectCards = document.querySelectorAll('.project-card');\n  projectCards.forEach(function (card) {\n    projectObserver.observe(card);\n  });\n\n  // Ensure profile overlay shows on hover across browsers by toggling a class\n  var profilePhotoEl = document.querySelector('#profileContainer .profile-photo');\n  if (profilePhotoEl) {\n    var overlayEl = profilePhotoEl.querySelector('.pong-overlay');\n    var playTextEl = profilePhotoEl.querySelector('.pong-overlay .play-text');\n    var showOverlay = function showOverlay() {\n      profilePhotoEl.classList.add('hovering');\n      if (overlayEl) {\n        overlayEl.style.setProperty('opacity', '1', 'important');\n        overlayEl.style.setProperty('pointer-events', 'auto', 'important');\n      }\n      if (playTextEl) {\n        playTextEl.style.setProperty('opacity', '1', 'important');\n        playTextEl.style.setProperty('transform', 'translateY(0)', 'important');\n      }\n    };\n    var hideOverlay = function hideOverlay() {\n      profilePhotoEl.classList.remove('hovering');\n      if (overlayEl) {\n        overlayEl.style.setProperty('opacity', '0', 'important');\n        overlayEl.style.setProperty('pointer-events', 'none', 'important');\n      }\n      if (playTextEl) {\n        playTextEl.style.setProperty('opacity', '0', 'important');\n        playTextEl.style.setProperty('transform', 'translateY(20px)', 'important');\n      }\n    };\n    profilePhotoEl.addEventListener('mouseenter', showOverlay);\n    profilePhotoEl.addEventListener('mouseleave', hideOverlay);\n\n    // Touch support: first tap shows overlay, then auto-hide\n    var touchVisibleTimeout;\n    profilePhotoEl.addEventListener('touchstart', function () {\n      showOverlay();\n      clearTimeout(touchVisibleTimeout);\n      touchVisibleTimeout = setTimeout(function () {\n        return hideOverlay();\n      }, 2500);\n    }, {\n      passive: true\n    });\n\n    // Also support focus/blur for accessibility (keyboard)\n    var imgEl = profilePhotoEl.querySelector('img');\n    if (imgEl) {\n      imgEl.setAttribute('tabindex', '0');\n      imgEl.addEventListener('focus', showOverlay);\n      imgEl.addEventListener('blur', hideOverlay);\n    }\n  }\n});\n\n// Sound system for Pong game - Global scope\nvar pongSounds = {\n  // Create sound effects using Web Audio API\n  context: null,\n  init: function init() {\n    try {\n      this.context = new (window.AudioContext || window.webkitAudioContext)();\n      console.log('🔊 Pong audio context initialized');\n    } catch (e) {\n      console.warn('🔇 Audio not supported:', e);\n      this.context = null;\n    }\n  },\n  playTone: function playTone(frequency, duration) {\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sine';\n    var volume = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;\n    if (!this.context) return;\n    try {\n      var oscillator = this.context.createOscillator();\n      var gainNode = this.context.createGain();\n      oscillator.connect(gainNode);\n      gainNode.connect(this.context.destination);\n      oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);\n      oscillator.type = type;\n      gainNode.gain.setValueAtTime(0, this.context.currentTime);\n      gainNode.gain.linearRampToValueAtTime(volume, this.context.currentTime + 0.01);\n      gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + duration);\n      oscillator.start(this.context.currentTime);\n      oscillator.stop(this.context.currentTime + duration);\n    } catch (e) {\n      console.warn('🔇 Sound playback failed:', e);\n    }\n  },\n  paddleHit: function paddleHit() {\n    // Sharp, quick hit sound\n    this.playTone(800, 0.1, 'square', 0.15);\n  },\n  wallBounce: function wallBounce() {\n    // Higher pitched bounce\n    this.playTone(1200, 0.08, 'triangle', 0.1);\n  },\n  score: function score() {\n    var _this = this;\n    // Pleasant scoring chime\n    setTimeout(function () {\n      return _this.playTone(523, 0.2, 'sine', 0.2);\n    }, 0); // C5\n    setTimeout(function () {\n      return _this.playTone(659, 0.2, 'sine', 0.2);\n    }, 100); // E5\n    setTimeout(function () {\n      return _this.playTone(784, 0.3, 'sine', 0.2);\n    }, 200); // G5\n  },\n  gameStart: function gameStart() {\n    var _this2 = this;\n    // Rising startup sound\n    setTimeout(function () {\n      return _this2.playTone(262, 0.15, 'sine', 0.15);\n    }, 0); // C4\n    setTimeout(function () {\n      return _this2.playTone(330, 0.15, 'sine', 0.15);\n    }, 150); // E4\n    setTimeout(function () {\n      return _this2.playTone(392, 0.2, 'sine', 0.15);\n    }, 300); // G4\n  },\n  gameOver: function gameOver() {\n    var _this3 = this;\n    // Descending game over sound\n    setTimeout(function () {\n      return _this3.playTone(523, 0.3, 'sine', 0.2);\n    }, 0); // C5\n    setTimeout(function () {\n      return _this3.playTone(494, 0.3, 'sine', 0.2);\n    }, 250); // B4\n    setTimeout(function () {\n      return _this3.playTone(440, 0.3, 'sine', 0.2);\n    }, 500); // A4\n    setTimeout(function () {\n      return _this3.playTone(392, 0.5, 'sine', 0.2);\n    }, 750); // G4\n  }\n};\n\n// Initialize sound system\npongSounds.init();\n\n// Pong Game Implementation\nfunction initializePongGame() {\n  console.log('=== PONG GAME INITIALIZATION STARTING ===');\n\n  // Wait a bit more for the DOM to be fully ready\n  setTimeout(function () {\n    console.log('Looking for elements...');\n    var profileContainer = document.getElementById('profileContainer');\n    var profilePhoto = document.querySelector('.profile-photo');\n    var pongOverlay = document.querySelector('.pong-overlay');\n    var pongGame = document.querySelector('.pong-game');\n    var canvas = document.getElementById('pongCanvas');\n\n    // Debug: Check if elements are found\n    console.log('Profile container:', profileContainer ? 'FOUND' : 'NOT FOUND');\n    console.log('Profile photo:', profilePhoto ? 'FOUND' : 'NOT FOUND');\n    console.log('Pong overlay:', pongOverlay ? 'FOUND' : 'NOT FOUND');\n    console.log('Pong game:', pongGame ? 'FOUND' : 'NOT FOUND');\n    console.log('Canvas:', canvas ? 'FOUND' : 'NOT FOUND');\n    if (!profileContainer || !profilePhoto || !pongOverlay || !pongGame || !canvas) {\n      console.error('CRITICAL ERROR: Some required elements were not found!');\n      console.log('Available elements with IDs:', Array.from(document.querySelectorAll('[id]')).map(function (el) {\n        return el.id;\n      }));\n      console.log('Available elements with class profile-photo:', document.querySelectorAll('.profile-photo'));\n      console.log('Available elements with class pong-overlay:', document.querySelectorAll('.pong-overlay'));\n      return;\n    }\n    console.log('All elements found successfully!');\n    var ctx = canvas.getContext('2d');\n\n    // Game state\n    var gameActive = false;\n    var gameStarted = false;\n    var playerScore = 0;\n    var cpuScore = 0;\n    var maxScore = 5;\n    var animationId = null;\n\n    // Game objects\n    var balls = [{\n      x: canvas.width / 2,\n      y: canvas.height / 2,\n      radius: 8,\n      speedX: 4,\n      speedY: 3,\n      maxSpeed: 12,\n      trail: [],\n      glow: 0,\n      glowDirection: 1\n    }];\n\n    // Game progression variables\n    var gameStartTime = 0;\n    var lastBallSpawn = 0;\n    var speedMultiplier = 1;\n    var particles = [];\n    var powerUps = [];\n    var playerPaddle = {\n      x: 10,\n      y: canvas.height / 2 - 40,\n      width: 8,\n      height: 80,\n      speed: 6,\n      glow: 0,\n      glowDirection: 1,\n      trail: []\n    };\n    var cpuPaddle = {\n      x: canvas.width - 18,\n      y: canvas.height / 2 - 40,\n      width: 8,\n      height: 80,\n      speed: 4,\n      glow: 0,\n      glowDirection: 1,\n      trail: []\n    };\n\n    // CPU player image (your photo)\n    var cpuImage = new Image();\n    cpuImage.src = 'assets/profile.png';\n    var cpuImageLoaded = false;\n    cpuImage.onload = function () {\n      cpuImageLoaded = true;\n    };\n\n    // Input handling\n    var keys = {};\n    document.addEventListener('keydown', function (e) {\n      keys[e.key.toLowerCase()] = true;\n      keys[e.code] = true;\n\n      // Global ESC handler for hero section game\n      if (e.key === 'Escape' && window.heroSectionGameRunning) {\n        console.log('Global ESC pressed - exiting hero section game');\n        e.preventDefault();\n        e.stopPropagation();\n        exitHeroSectionGame();\n      }\n    });\n    document.addEventListener('keyup', function (e) {\n      keys[e.key.toLowerCase()] = false;\n      keys[e.code] = false;\n    });\n\n    // Click to start Pong\n    if (pongOverlay) {\n      console.log('Adding click event listener to pong overlay');\n      pongOverlay.addEventListener('click', function (e) {\n        console.log('Pong overlay clicked!');\n        e.preventDefault();\n        e.stopPropagation();\n        startPongGame();\n      });\n    } else {\n      console.error('Pong overlay not found, cannot add click listener');\n    }\n\n    // Also add click event to the profile photo as fallback\n    if (profilePhoto) {\n      console.log('Adding click event listener to profile photo');\n      profilePhoto.addEventListener('click', function (e) {\n        console.log('Profile photo clicked!');\n        e.preventDefault();\n        e.stopPropagation();\n        startPongGame();\n      });\n    }\n\n    // Add click event to the profile image itself\n    var profileImage = document.getElementById('profileImage');\n    if (profileImage) {\n      console.log('Adding click event listener to profile image');\n      profileImage.addEventListener('click', function (e) {\n        console.log('Profile image clicked!');\n        e.preventDefault();\n        e.stopPropagation();\n        startPongGame();\n      });\n    } // Canvas click to start game\n    canvas.addEventListener('click', function () {\n      if (!gameStarted && gameActive) {\n        startGame();\n      }\n    });\n\n    // Game control buttons\n    var playAgainBtn = document.getElementById('playAgainBtn');\n    var backToPhotoBtn = document.getElementById('backToPhotoBtn');\n    console.log('Play again button:', playAgainBtn);\n    console.log('Back to photo button:', backToPhotoBtn);\n    if (playAgainBtn) {\n      playAgainBtn.addEventListener('click', function () {\n        console.log('Play again clicked');\n        resetGame();\n        startGame();\n      });\n    }\n    if (backToPhotoBtn) {\n      backToPhotoBtn.addEventListener('click', function () {\n        console.log('Back to photo clicked');\n        exitPongGame();\n      });\n    }\n    function startPongGame() {\n      console.log('Starting hero section Pong game');\n\n      // Check if game is already running\n      if (window.heroSectionGameRunning) {\n        console.log('Game already running, preventing duplicate start');\n        return;\n      }\n\n      // Set game running flag\n      window.heroSectionGameRunning = true;\n      var heroSection = document.querySelector('.hero');\n      var profileContainer = document.getElementById('profileContainer');\n      var heroContent = document.querySelector('.hero-content');\n      if (!heroSection) {\n        console.error('Hero section not found');\n        window.heroSectionGameRunning = false; // Reset flag on error\n        return;\n      }\n\n      // Remove any existing game overlay\n      var existingOverlay = document.getElementById('heroSectionPongGame');\n      if (existingOverlay) {\n        console.log('Removing existing game overlay');\n        existingOverlay.remove();\n      }\n\n      // Fade out hero elements\n      var elementsToFade = [heroContent];\n      elementsToFade.forEach(function (element) {\n        if (element) {\n          element.style.transition = 'opacity 0.5s ease-in-out';\n          element.style.opacity = '0.1'; // Keep slightly visible\n        }\n      });\n\n      // Hide the profile container with fade\n      if (profileContainer) {\n        profileContainer.style.transition = 'opacity 0.3s ease-in-out';\n        profileContainer.style.opacity = '0';\n        setTimeout(function () {\n          profileContainer.style.display = 'none';\n        }, 300);\n      }\n\n      // Create game overlay that fills the hero section (transparent background)\n      var gameOverlay = document.createElement('div');\n      gameOverlay.id = 'heroSectionPongGame';\n      gameOverlay.style.cssText = \"\\n            position: absolute;\\n            top: 0;\\n            left: 0;\\n            width: 100%;\\n            height: 100%;\\n            background: transparent;\\n            z-index: 5;\\n            display: flex;\\n            justify-content: center;\\n            align-items: center;\\n            font-family: 'Inter', sans-serif;\\n            opacity: 0;\\n            transition: opacity 0.5s ease-in-out;\\n        \";\n\n      // Ensure hero section is positioned relatively\n      if (getComputedStyle(heroSection).position === 'static') {\n        heroSection.style.position = 'relative';\n      }\n\n      // Get hero section dimensions\n      var heroRect = heroSection.getBoundingClientRect();\n      var heroWidth = heroSection.offsetWidth;\n      var heroHeight = heroSection.offsetHeight;\n\n      // Create game canvas that fills the entire hero section\n      var canvas = document.createElement('canvas');\n      canvas.id = 'heroSectionPongCanvas';\n      canvas.width = heroWidth; // Full width\n      canvas.height = heroHeight; // Full height\n      canvas.style.cssText = \"\\n            position: absolute;\\n            top: 0;\\n            left: 0;\\n            width: 100%;\\n            height: 100%;\\n            cursor: none;\\n            background: transparent;\\n        \";\n\n      // Create UI overlay\n      var uiOverlay = document.createElement('div');\n      uiOverlay.style.cssText = \"\\n            position: absolute;\\n            top: 0;\\n            left: 0;\\n            width: 100%;\\n            height: 100%;\\n            pointer-events: none;\\n            color: white;\\n            z-index: 6;\\n        \";\n\n      // Score display\n      var scoreBoard = document.createElement('div');\n      scoreBoard.style.cssText = \"\\n            position: absolute;\\n            top: 20px;\\n            left: 50%;\\n            transform: translateX(-50%);\\n            font-size: 2.5rem;\\n            font-weight: bold;\\n            text-shadow: 0 2px 10px rgba(0,0,0,0.5);\\n        \";\n      scoreBoard.innerHTML = \"\\n            <span id=\\\"heroSectionPlayerScore\\\">0</span>\\n            <span style=\\\"margin: 0 30px;\\\">-</span>\\n            <span id=\\\"heroSectionCpuScore\\\">0</span>\\n        \";\n\n      // Game message\n      var gameMessage = document.createElement('div');\n      gameMessage.id = 'heroSectionGameMessage';\n      gameMessage.style.cssText = \"\\n            position: absolute;\\n            top: 50%;\\n            left: 50%;\\n            transform: translate(-50%, -50%);\\n            font-size: 1.8rem;\\n            font-weight: bold;\\n            text-align: center;\\n            text-shadow: 0 2px 10px rgba(0,0,0,0.5);\\n            max-width: 80%;\\n        \";\n      gameMessage.textContent = \"\".concat((0, _i18n.t)('game.pong.moveKeys'), \" - \").concat((0, _i18n.t)('game.pong.clickToStart'), \" - \").concat((0, _i18n.t)('game.pong.escToExit'));\n\n      // Controls hint\n      var controlsHint = document.createElement('div');\n      controlsHint.style.cssText = \"\\n            position: absolute;\\n            bottom: 20px;\\n            left: 50%;\\n            transform: translateX(-50%);\\n            font-size: 1rem;\\n            text-align: center;\\n            opacity: 0.9;\\n            text-shadow: 0 2px 10px rgba(0,0,0,0.5);\\n        \";\n      controlsHint.innerHTML = \"\\n            <div>\".concat((0, _i18n.t)('game.pong.playerLabel'), \": \").concat((0, _i18n.t)('game.pong.moveKeys'), \"</div>\\n            <div style=\\\"margin-top: 5px;\\\">\").concat((0, _i18n.t)('game.pong.escToExit'), \" \\u2022 \").concat((0, _i18n.t)('game.pong.clickToStart'), \"</div>\\n        \");\n\n      // Exit on click anywhere\n      gameOverlay.addEventListener('click', function (e) {\n        if (e.target === gameOverlay) {\n          exitHeroSectionGame();\n        }\n      });\n\n      // Assemble the UI\n      uiOverlay.appendChild(scoreBoard);\n      uiOverlay.appendChild(gameMessage);\n      uiOverlay.appendChild(controlsHint);\n      gameOverlay.appendChild(canvas);\n      gameOverlay.appendChild(uiOverlay);\n      heroSection.appendChild(gameOverlay);\n\n      // Fade in the game overlay\n      setTimeout(function () {\n        gameOverlay.style.opacity = '1';\n      }, 100);\n\n      // Initialize hero section game\n      initializeHeroSectionPongGame(canvas);\n    }\n    function exitPongGame() {\n      console.log('Exiting Pong game');\n      gameActive = false;\n      gameStarted = false;\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n      pongGame.style.display = 'none';\n      profilePhoto.style.display = 'block';\n      document.querySelector('.game-over-screen').style.display = 'none';\n    }\n    function exitFullscreenGame() {\n      console.log('Exiting fullscreen Pong game');\n\n      // Stop the game\n      if (window.fullscreenGameActive) {\n        window.fullscreenGameActive = false;\n      }\n      if (window.fullscreenAnimationId) {\n        cancelAnimationFrame(window.fullscreenAnimationId);\n      }\n\n      // Remove the fullscreen overlay\n      var gameOverlay = document.getElementById('fullscreenPongGame');\n      if (gameOverlay) {\n        gameOverlay.remove();\n      }\n\n      // Show the profile container again\n      var profileContainer = document.getElementById('profileContainer');\n      if (profileContainer) {\n        profileContainer.style.display = 'block';\n      }\n\n      // Remove event listeners\n      document.removeEventListener('keydown', window.fullscreenKeyHandler);\n      document.removeEventListener('keyup', window.fullscreenKeyUpHandler);\n    }\n    function exitHeroSectionGame() {\n      console.log('Exiting hero section Pong game');\n\n      // Reset game running flag\n      window.heroSectionGameRunning = false;\n      window.heroSectionGameStarted = false;\n\n      // Stop the game\n      if (window.heroSectionGameActive) {\n        window.heroSectionGameActive = false;\n      }\n      if (window.heroSectionAnimationId) {\n        cancelAnimationFrame(window.heroSectionAnimationId);\n        window.heroSectionAnimationId = null;\n      }\n\n      // Fade out game overlay\n      var gameOverlay = document.getElementById('heroSectionPongGame');\n      if (gameOverlay) {\n        gameOverlay.style.transition = 'opacity 0.3s ease-in-out';\n        gameOverlay.style.opacity = '0';\n        setTimeout(function () {\n          if (gameOverlay.parentNode) {\n            gameOverlay.remove();\n          }\n          // Ensure no residual overlays are left\n          var residualOverlays = document.querySelectorAll('[id*=\"heroSectionPongGame\"]');\n          residualOverlays.forEach(function (overlay) {\n            if (overlay.parentNode) {\n              overlay.remove();\n            }\n          });\n        }, 300);\n      }\n\n      // Fade in hero elements\n      var heroContent = document.querySelector('.hero-content');\n      var profileContainer = document.getElementById('profileContainer');\n      if (heroContent) {\n        setTimeout(function () {\n          heroContent.style.transition = 'opacity 0.5s ease-in-out';\n          heroContent.style.opacity = '1';\n        }, 200);\n      }\n      if (profileContainer) {\n        setTimeout(function () {\n          profileContainer.style.display = 'block';\n          profileContainer.style.opacity = '0';\n          profileContainer.style.transition = 'opacity 0.5s ease-in-out';\n          setTimeout(function () {\n            // Remove inline opacity to allow CSS hover effects\n            profileContainer.style.removeProperty('opacity');\n            profileContainer.style.removeProperty('transition');\n          }, 50);\n        }, 300);\n      }\n\n      // Remove event listeners\n      if (window.heroSectionKeyHandler) {\n        document.removeEventListener('keydown', window.heroSectionKeyHandler);\n      }\n      if (window.heroSectionKeyUpHandler) {\n        document.removeEventListener('keyup', window.heroSectionKeyUpHandler);\n      }\n      console.log('Hero section game exited successfully');\n    }\n    function startGame() {\n      gameStarted = true;\n      gameStartTime = Date.now();\n      lastBallSpawn = gameStartTime;\n      speedMultiplier = 1;\n      particles = [];\n      powerUps = [];\n      pongSounds.gameStart(); // 🔊 Game start sound\n      resetBalls();\n      updateGameMessage('');\n      document.querySelector('.game-over-screen').style.display = 'none';\n    }\n    function resetGame() {\n      playerScore = 0;\n      cpuScore = 0;\n      gameStartTime = 0;\n      lastBallSpawn = 0;\n      speedMultiplier = 1;\n      particles = [];\n      powerUps = [];\n      balls = [{\n        x: canvas.width / 2,\n        y: canvas.height / 2,\n        radius: 8,\n        speedX: 4,\n        speedY: 3,\n        maxSpeed: 12,\n        trail: [],\n        glow: 0,\n        glowDirection: 1\n      }];\n      updateScore();\n      resetBalls();\n      gameStarted = false;\n    }\n    function resetBalls() {\n      balls.forEach(function (ball) {\n        ball.x = canvas.width / 2 + (Math.random() - 0.5) * 100;\n        ball.y = canvas.height / 2 + (Math.random() - 0.5) * 100;\n        ball.speedX = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 2);\n        ball.speedY = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2);\n        ball.trail = [];\n      });\n    }\n\n    // Particle system for visual effects\n    function createParticles(x, y) {\n      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#3498db';\n      var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n      for (var i = 0; i < count; i++) {\n        particles.push({\n          x: x,\n          y: y,\n          vx: (Math.random() - 0.5) * 10,\n          vy: (Math.random() - 0.5) * 10,\n          life: 1,\n          decay: 0.02 + Math.random() * 0.02,\n          size: 2 + Math.random() * 3,\n          color: color\n        });\n      }\n    }\n    function updateParticles() {\n      particles = particles.filter(function (particle) {\n        particle.x += particle.vx;\n        particle.y += particle.vy;\n        particle.vx *= 0.98;\n        particle.vy *= 0.98;\n        particle.life -= particle.decay;\n        return particle.life > 0;\n      });\n    }\n    function renderParticles() {\n      particles.forEach(function (particle) {\n        ctx.save();\n        ctx.globalAlpha = particle.life;\n        ctx.fillStyle = particle.color;\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      });\n    }\n\n    // Power-up system\n    function spawnPowerUp() {\n      if (Math.random() < 0.3) {\n        // 30% chance\n        powerUps.push({\n          x: canvas.width * 0.2 + Math.random() * canvas.width * 0.6,\n          y: canvas.height * 0.2 + Math.random() * canvas.height * 0.6,\n          type: Math.random() > 0.5 ? 'speed' : 'multi',\n          life: 1,\n          pulse: 0,\n          collected: false\n        });\n      }\n    }\n    function updatePowerUps() {\n      powerUps = powerUps.filter(function (powerUp) {\n        powerUp.pulse += 0.1;\n        powerUp.life -= 0.005;\n\n        // Check collision with balls\n        balls.forEach(function (ball) {\n          var distance = Math.sqrt(Math.pow(ball.x - powerUp.x, 2) + Math.pow(ball.y - powerUp.y, 2));\n          if (distance < ball.radius + 15 && !powerUp.collected) {\n            powerUp.collected = true;\n            applyPowerUp(powerUp.type);\n            createParticles(powerUp.x, powerUp.y, '#f39c12', 10);\n            pongSounds.score(); // Use score sound for power-up collection\n          }\n        });\n        return powerUp.life > 0 && !powerUp.collected;\n      });\n    }\n    function applyPowerUp(type) {\n      if (type === 'speed') {\n        speedMultiplier += 0.3;\n      } else if (type === 'multi') {\n        spawnExtraBall();\n      }\n    }\n    function spawnExtraBall() {\n      if (balls.length < 4) {\n        // Max 4 balls\n        var newBall = {\n          x: canvas.width / 2,\n          y: canvas.height / 2,\n          radius: 6 + Math.random() * 4,\n          speedX: (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 3) * speedMultiplier,\n          speedY: (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 3) * speedMultiplier,\n          maxSpeed: 15,\n          trail: [],\n          glow: 0,\n          glowDirection: 1\n        };\n        balls.push(newBall);\n      }\n    }\n    function renderPowerUps() {\n      powerUps.forEach(function (powerUp) {\n        ctx.save();\n        ctx.globalAlpha = powerUp.life;\n        var pulseSize = 15 + Math.sin(powerUp.pulse) * 3;\n        var color = powerUp.type === 'speed' ? '#e74c3c' : '#f39c12';\n\n        // Outer glow\n        ctx.shadowBlur = 20;\n        ctx.shadowColor = color;\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(powerUp.x, powerUp.y, pulseSize, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Inner circle\n        ctx.shadowBlur = 0;\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(powerUp.x, powerUp.y, pulseSize * 0.6, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Icon\n        ctx.fillStyle = color;\n        ctx.font = '12px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText(powerUp.type === 'speed' ? '⚡' : '●●', powerUp.x, powerUp.y + 4);\n        ctx.restore();\n      });\n    }\n    function updateScore() {\n      document.getElementById('playerScore').textContent = playerScore;\n      document.getElementById('cpuScore').textContent = cpuScore;\n    }\n    function updateGameMessage(message) {\n      document.getElementById('gameMessage').textContent = message;\n    }\n    function gameLoop() {\n      if (!gameActive) return;\n      update();\n      render();\n      animationId = requestAnimationFrame(gameLoop);\n    }\n    function update() {\n      if (!gameStarted) return;\n\n      // Calculate game progression\n      var gameTime = Date.now() - gameStartTime;\n      var timeInSeconds = gameTime / 1000;\n\n      // Progressive speed increase every 10 seconds\n      speedMultiplier = 1 + Math.floor(timeInSeconds / 10) * 0.2;\n\n      // Spawn extra balls occasionally (every 15 seconds, max 3 balls)\n      if (timeInSeconds > 15 && gameTime - lastBallSpawn > 15000 && balls.length < 3) {\n        spawnExtraBall();\n        lastBallSpawn = gameTime;\n      }\n\n      // Spawn power-ups occasionally\n      if (Math.random() < 0.001) {\n        // Very rare\n        spawnPowerUp();\n      }\n\n      // Update paddle glow effects\n      playerPaddle.glow += playerPaddle.glowDirection * 0.05;\n      if (playerPaddle.glow >= 1 || playerPaddle.glow <= 0) {\n        playerPaddle.glowDirection *= -1;\n      }\n      cpuPaddle.glow += cpuPaddle.glowDirection * 0.03;\n      if (cpuPaddle.glow >= 1 || cpuPaddle.glow <= 0) {\n        cpuPaddle.glowDirection *= -1;\n      }\n\n      // Player input with improved responsiveness\n      var paddleSpeed = playerPaddle.speed * (1 + speedMultiplier * 0.1);\n      if ((keys['w'] || keys['ArrowUp']) && playerPaddle.y > 0) {\n        playerPaddle.y -= paddleSpeed;\n        // Add trail effect\n        playerPaddle.trail.push({\n          x: playerPaddle.x + playerPaddle.width / 2,\n          y: playerPaddle.y + playerPaddle.height / 2,\n          life: 1\n        });\n      }\n      if ((keys['s'] || keys['ArrowDown']) && playerPaddle.y < canvas.height - playerPaddle.height) {\n        playerPaddle.y += paddleSpeed;\n        // Add trail effect\n        playerPaddle.trail.push({\n          x: playerPaddle.x + playerPaddle.width / 2,\n          y: playerPaddle.y + playerPaddle.height / 2,\n          life: 1\n        });\n      }\n\n      // Update paddle trails\n      playerPaddle.trail = playerPaddle.trail.filter(function (point) {\n        point.life -= 0.05;\n        return point.life > 0;\n      });\n      cpuPaddle.trail = cpuPaddle.trail.filter(function (point) {\n        point.life -= 0.05;\n        return point.life > 0;\n      });\n\n      // Enhanced CPU AI that tracks closest ball\n      var closestBall = balls[0];\n      var closestDistance = Infinity;\n      balls.forEach(function (ball) {\n        var distance = Math.abs(ball.x - cpuPaddle.x);\n        if (distance < closestDistance && ball.speedX > 0) {\n          closestDistance = distance;\n          closestBall = ball;\n        }\n      });\n      if (closestBall) {\n        var cpuCenter = cpuPaddle.y + cpuPaddle.height / 2;\n        var ballCenter = closestBall.y;\n        var cpuSpeed = cpuPaddle.speed * (1 + speedMultiplier * 0.08);\n        if (cpuCenter < ballCenter - 15) {\n          cpuPaddle.y += cpuSpeed;\n          cpuPaddle.trail.push({\n            x: cpuPaddle.x + cpuPaddle.width / 2,\n            y: cpuPaddle.y + cpuPaddle.height / 2,\n            life: 1\n          });\n        } else if (cpuCenter > ballCenter + 15) {\n          cpuPaddle.y -= cpuSpeed;\n          cpuPaddle.trail.push({\n            x: cpuPaddle.x + cpuPaddle.width / 2,\n            y: cpuPaddle.y + cpuPaddle.height / 2,\n            life: 1\n          });\n        }\n      }\n\n      // Keep CPU paddle in bounds\n      cpuPaddle.y = Math.max(0, Math.min(canvas.height - cpuPaddle.height, cpuPaddle.y));\n\n      // Update all balls\n      balls.forEach(function (ball, ballIndex) {\n        // Update ball glow effect\n        ball.glow += ball.glowDirection * 0.1;\n        if (ball.glow >= 1 || ball.glow <= 0) {\n          ball.glowDirection *= -1;\n        }\n\n        // Apply speed multiplier\n        var currentSpeedX = ball.speedX * speedMultiplier;\n        var currentSpeedY = ball.speedY * speedMultiplier;\n\n        // Ball movement\n        ball.x += currentSpeedX;\n        ball.y += currentSpeedY;\n\n        // Add trail effect\n        ball.trail.push({\n          x: ball.x,\n          y: ball.y,\n          life: 1\n        });\n\n        // Limit trail length\n        if (ball.trail.length > 10) {\n          ball.trail.shift();\n        }\n\n        // Update trail\n        ball.trail = ball.trail.filter(function (point) {\n          point.life -= 0.1;\n          return point.life > 0;\n        });\n\n        // Ball collision with top/bottom walls\n        if (ball.y <= ball.radius || ball.y >= canvas.height - ball.radius) {\n          ball.speedY = -ball.speedY;\n          createParticles(ball.x, ball.y, '#3498db', 3);\n          pongSounds.wallBounce(); // 🔊 Wall bounce sound\n        }\n\n        // Ball collision with player paddle\n        if (ball.x - ball.radius <= playerPaddle.x + playerPaddle.width && ball.y >= playerPaddle.y && ball.y <= playerPaddle.y + playerPaddle.height && ball.speedX < 0) {\n          ball.speedX = -ball.speedX;\n          ball.speedY += (ball.y - (playerPaddle.y + playerPaddle.height / 2)) * 0.15;\n          ball.speedX = Math.min(ball.maxSpeed, Math.abs(ball.speedX)) * Math.sign(ball.speedX);\n          createParticles(ball.x, ball.y, '#3498db', 5);\n          pongSounds.paddleHit(); // 🔊 Player paddle hit sound\n        }\n\n        // Ball collision with CPU paddle\n        if (ball.x + ball.radius >= cpuPaddle.x && ball.y >= cpuPaddle.y && ball.y <= cpuPaddle.y + cpuPaddle.height && ball.speedX > 0) {\n          ball.speedX = -ball.speedX;\n          ball.speedY += (ball.y - (cpuPaddle.y + cpuPaddle.height / 2)) * 0.15;\n          ball.speedX = -Math.min(ball.maxSpeed, Math.abs(ball.speedX));\n          createParticles(ball.x, ball.y, '#e74c3c', 5);\n          pongSounds.paddleHit(); // 🔊 CPU paddle hit sound\n        }\n\n        // Ball out of bounds (scoring)\n        if (ball.x < -ball.radius) {\n          cpuScore++;\n          createParticles(0, ball.y, '#e74c3c', 8);\n          pongSounds.score(); // 🔊 Score sound\n          updateScore();\n\n          // Remove this ball if multiple balls exist\n          if (balls.length > 1) {\n            balls.splice(ballIndex, 1);\n          } else {\n            checkGameEnd();\n            if (gameStarted) resetBalls();\n          }\n        } else if (ball.x > canvas.width + ball.radius) {\n          playerScore++;\n          createParticles(canvas.width, ball.y, '#3498db', 8);\n          pongSounds.score(); // 🔊 Score sound\n          updateScore();\n\n          // Remove this ball if multiple balls exist\n          if (balls.length > 1) {\n            balls.splice(ballIndex, 1);\n          } else {\n            checkGameEnd();\n            if (gameStarted) resetBalls();\n          }\n        }\n      });\n\n      // Update particles and power-ups\n      updateParticles();\n      updatePowerUps();\n    }\n    function checkGameEnd() {\n      if (playerScore >= maxScore || cpuScore >= maxScore) {\n        gameStarted = false;\n        pongSounds.gameOver(); // 🔊 Game over sound\n        showGameOver();\n      }\n    }\n    function showGameOver() {\n      var gameOverScreen = document.querySelector('.game-over-screen');\n      var gameResult = document.getElementById('gameResult');\n      var finalPlayerScore = document.getElementById('finalPlayerScore');\n      var finalCpuScore = document.getElementById('finalCpuScore');\n      if (playerScore >= maxScore) {\n        gameResult.textContent = \"\\uD83C\\uDF89 \".concat((0, _i18n.t)('game.pong.youWon'));\n        gameResult.style.color = '#28a745';\n      } else {\n        gameResult.textContent = \"\\uD83D\\uDCBB \".concat((0, _i18n.t)('game.pong.fizWon'));\n        gameResult.style.color = '#dc3545';\n      }\n      finalPlayerScore.textContent = playerScore;\n      finalCpuScore.textContent = cpuScore;\n      gameOverScreen.style.display = 'flex';\n    }\n    function render() {\n      // Clear canvas with complete transparency\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Draw animated center line\n      var lineOffset = Math.sin(Date.now() * 0.002) * 2;\n      ctx.save();\n      ctx.setLineDash([5, 5]);\n      ctx.strokeStyle = '#3498db';\n      ctx.lineWidth = 3;\n      ctx.shadowBlur = 10;\n      ctx.shadowColor = '#3498db';\n      ctx.beginPath();\n      ctx.moveTo(canvas.width / 2 + lineOffset, 0);\n      ctx.lineTo(canvas.width / 2 + lineOffset, canvas.height);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      ctx.restore();\n\n      // Draw paddle trails\n      function drawTrail(trail, color) {\n        trail.forEach(function (point, index) {\n          ctx.save();\n          ctx.globalAlpha = point.life * 0.3;\n          ctx.fillStyle = color;\n          ctx.beginPath();\n          ctx.arc(point.x, point.y, 2 * point.life, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n        });\n      }\n      drawTrail(playerPaddle.trail, '#3498db');\n      drawTrail(cpuPaddle.trail, '#e74c3c');\n\n      // Draw enhanced player paddle\n      ctx.save();\n      var playerGlow = 10 + playerPaddle.glow * 5;\n      ctx.shadowBlur = playerGlow;\n      ctx.shadowColor = '#3498db';\n\n      // Create gradient for paddle\n      var playerGradient = ctx.createLinearGradient(playerPaddle.x, playerPaddle.y, playerPaddle.x + playerPaddle.width, playerPaddle.y + playerPaddle.height);\n      playerGradient.addColorStop(0, '#5dade2');\n      playerGradient.addColorStop(0.5, '#3498db');\n      playerGradient.addColorStop(1, '#2980b9');\n      ctx.fillStyle = playerGradient;\n      ctx.fillRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height);\n\n      // Add border\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height);\n      ctx.restore();\n\n      // Draw enhanced CPU paddle with your photo\n      ctx.save();\n      var cpuGlow = 10 + cpuPaddle.glow * 5;\n      ctx.shadowBlur = cpuGlow;\n      ctx.shadowColor = '#e74c3c';\n      if (cpuImageLoaded) {\n        ctx.beginPath();\n        ctx.roundRect(cpuPaddle.x, cpuPaddle.y, cpuPaddle.width, cpuPaddle.height, 4);\n        ctx.clip();\n\n        // Draw the image scaled to fit the paddle\n        var aspectRatio = cpuImage.width / cpuImage.height;\n        var paddleAspectRatio = cpuPaddle.width / cpuPaddle.height;\n        var drawWidth, drawHeight, drawX, drawY;\n        if (aspectRatio > paddleAspectRatio) {\n          drawHeight = cpuPaddle.height;\n          drawWidth = drawHeight * aspectRatio;\n          drawX = cpuPaddle.x - (drawWidth - cpuPaddle.width) / 2;\n          drawY = cpuPaddle.y;\n        } else {\n          drawWidth = cpuPaddle.width;\n          drawHeight = drawWidth / aspectRatio;\n          drawX = cpuPaddle.x;\n          drawY = cpuPaddle.y - (drawHeight - cpuPaddle.height) / 2;\n        }\n        ctx.drawImage(cpuImage, drawX, drawY, drawWidth, drawHeight);\n        ctx.restore();\n\n        // Add animated border\n        ctx.save();\n        ctx.strokeStyle = '#e74c3c';\n        ctx.lineWidth = 2 + Math.sin(Date.now() * 0.005) * 1;\n        ctx.shadowBlur = cpuGlow;\n        ctx.shadowColor = '#e74c3c';\n        ctx.strokeRect(cpuPaddle.x, cpuPaddle.y, cpuPaddle.width, cpuPaddle.height);\n        ctx.restore();\n      } else {\n        // Fallback gradient\n        var cpuGradient = ctx.createLinearGradient(cpuPaddle.x, cpuPaddle.y, cpuPaddle.x + cpuPaddle.width, cpuPaddle.y + cpuPaddle.height);\n        cpuGradient.addColorStop(0, '#ec7063');\n        cpuGradient.addColorStop(0.5, '#e74c3c');\n        cpuGradient.addColorStop(1, '#c0392b');\n        ctx.fillStyle = cpuGradient;\n        ctx.fillRect(cpuPaddle.x, cpuPaddle.y, cpuPaddle.width, cpuPaddle.height);\n        ctx.strokeStyle = '#fff';\n        ctx.lineWidth = 1;\n        ctx.strokeRect(cpuPaddle.x, cpuPaddle.y, cpuPaddle.width, cpuPaddle.height);\n      }\n      ctx.restore();\n\n      // Draw all balls with enhanced effects\n      balls.forEach(function (ball) {\n        // Draw ball trail\n        ball.trail.forEach(function (point, index) {\n          ctx.save();\n          ctx.globalAlpha = point.life * 0.4;\n          ctx.fillStyle = '#fff';\n          ctx.beginPath();\n          ctx.arc(point.x, point.y, ball.radius * point.life * 0.8, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n        });\n\n        // Draw main ball with pulsing glow\n        ctx.save();\n        var ballGlow = 15 + ball.glow * 10;\n        ctx.shadowBlur = ballGlow;\n        ctx.shadowColor = '#fff';\n\n        // Outer glow\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(ball.x, ball.y, ball.radius + 2, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Inner ball with gradient\n        var ballGradient = ctx.createRadialGradient(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0, ball.x, ball.y, ball.radius);\n        ballGradient.addColorStop(0, '#fff');\n        ballGradient.addColorStop(0.7, '#f8f9fa');\n        ballGradient.addColorStop(1, '#e9ecef');\n        ctx.fillStyle = ballGradient;\n        ctx.beginPath();\n        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Add highlight\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.3, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      });\n\n      // Render particles and power-ups\n      renderParticles();\n      renderPowerUps();\n\n      // Display game info with enhanced styling\n      if (gameStarted) {\n        var gameTime = Math.floor((Date.now() - gameStartTime) / 1000);\n        var speed = speedMultiplier.toFixed(1);\n        ctx.save();\n        ctx.textAlign = 'center';\n        ctx.shadowBlur = 3;\n        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n\n        // Main game stats\n        ctx.fillStyle = '#fff';\n        ctx.font = 'bold 14px Arial';\n        ctx.fillText(\"Time: \".concat(gameTime, \"s | Speed: \").concat(speed, \"x | Balls: \").concat(balls.length), canvas.width / 2, 25);\n\n        // Special effects indicators with proper spacing\n        var yOffset = 45;\n        if (speedMultiplier > 1.5) {\n          ctx.fillStyle = '#f39c12';\n          ctx.font = 'bold 12px Arial';\n          ctx.fillText('⚡ SPEED MODE ⚡', canvas.width / 2, yOffset);\n          yOffset += 20;\n        }\n        if (balls.length > 1) {\n          ctx.fillStyle = '#e74c3c';\n          ctx.font = 'bold 12px Arial';\n          ctx.fillText('🔥 MULTI-BALL 🔥', canvas.width / 2, yOffset);\n        }\n        ctx.restore();\n      }\n    }\n  }, 500); // Close the setTimeout from initializePongGame\n}\n\n// ============================================\n// HERO SECTION PONG GAME IMPLEMENTATION\n// ============================================\n\nfunction initializeHeroSectionPongGame(canvas) {\n  console.log('Initializing hero section Pong game');\n  var ctx = canvas.getContext('2d');\n\n  // Game variables\n  window.heroSectionGameActive = true;\n  window.heroSectionGameStarted = false;\n\n  // Game objects scaled to canvas size\n  var game = {\n    balls: [{\n      x: canvas.width / 2,\n      y: canvas.height / 2,\n      vx: 6,\n      vy: 3,\n      radius: 12,\n      maxSpeed: 15,\n      trail: [],\n      glow: 0,\n      glowDirection: 1\n    }],\n    player: {\n      x: 20,\n      // Left edge\n      y: canvas.height / 2 - 60,\n      width: 15,\n      height: 120,\n      speed: 7,\n      score: 0,\n      glow: 0,\n      glowDirection: 1,\n      trail: []\n    },\n    cpu: {\n      x: canvas.width - 35,\n      // Right edge\n      y: canvas.height / 2 - 60,\n      width: 15,\n      height: 120,\n      speed: 5,\n      score: 0,\n      glow: 0,\n      glowDirection: 1,\n      trail: []\n    },\n    keys: {\n      up: false,\n      down: false\n    },\n    startTime: 0,\n    lastBallSpawn: 0,\n    speedMultiplier: 1,\n    particles: [],\n    powerUps: []\n  };\n\n  // Load CPU image (user's profile photo)\n  var cpuImage = new Image();\n  cpuImage.src = 'assets/profile.png';\n\n  // Key handlers\n  window.heroSectionKeyHandler = function (e) {\n    // Only handle keys when the hero section game is active\n    if (!window.heroSectionGameRunning) {\n      return;\n    }\n    console.log('Hero Section Key pressed:', e.key);\n    switch (e.key.toLowerCase()) {\n      case 'w':\n      case 'arrowup':\n        e.preventDefault();\n        e.stopPropagation();\n        game.keys.up = true;\n        break;\n      case 's':\n      case 'arrowdown':\n        e.preventDefault();\n        e.stopPropagation();\n        game.keys.down = true;\n        break;\n      case 'escape':\n        console.log('ESC key pressed - exiting game');\n        e.preventDefault();\n        e.stopPropagation();\n        exitHeroSectionGame();\n        break;\n    }\n  };\n  window.heroSectionKeyUpHandler = function (e) {\n    // Only handle keys when the hero section game is active\n    if (!window.heroSectionGameRunning) {\n      return;\n    }\n    switch (e.key.toLowerCase()) {\n      case 'w':\n      case 'arrowup':\n        e.preventDefault();\n        e.stopPropagation();\n        game.keys.up = false;\n        break;\n      case 's':\n      case 'arrowdown':\n        e.preventDefault();\n        e.stopPropagation();\n        game.keys.down = false;\n        break;\n    }\n  };\n\n  // Add event listeners\n  document.addEventListener('keydown', window.heroSectionKeyHandler);\n  document.addEventListener('keyup', window.heroSectionKeyUpHandler);\n\n  // Click to start or restart\n  canvas.addEventListener('click', function () {\n    if (!window.heroSectionGameStarted) {\n      // First time starting the game\n      window.heroSectionGameStarted = true;\n      game.startTime = Date.now();\n      game.lastBallSpawn = game.startTime;\n      game.speedMultiplier = 1;\n      game.particles = [];\n      game.powerUps = [];\n      pongSounds.gameStart(); // 🔊 Game start sound\n      updateHeroSectionMessage((0, _i18n.t)('game.pong.gameStarted'));\n      setTimeout(function () {\n        return updateHeroSectionMessage('');\n      }, 1000);\n    } else if (window.heroSectionGameStarted && !window.heroSectionGameActive) {\n      // Game has ended, restart it\n      console.log('Restarting hero section game');\n      pongSounds.gameStart(); // 🔊 Game restart sound\n      game.player.score = 0;\n      game.cpu.score = 0;\n      game.startTime = Date.now();\n      game.lastBallSpawn = game.startTime;\n      game.speedMultiplier = 1;\n      game.particles = [];\n      game.powerUps = [];\n      updateHeroSectionScore();\n      resetHeroSectionBall();\n      window.heroSectionGameActive = true;\n      updateHeroSectionMessage((0, _i18n.t)('game.pong.gameStarted'));\n      setTimeout(function () {\n        return updateHeroSectionMessage('');\n      }, 1000);\n      // Restart the game loop\n      heroSectionGameLoop();\n    }\n  });\n\n  // Game functions\n  function updateHeroSectionMessage(message) {\n    var messageEl = document.getElementById('heroSectionGameMessage');\n    if (messageEl) {\n      messageEl.textContent = message;\n    }\n  }\n  function updateHeroSectionScore() {\n    var playerScoreEl = document.getElementById('heroSectionPlayerScore');\n    var cpuScoreEl = document.getElementById('heroSectionCpuScore');\n    if (playerScoreEl) playerScoreEl.textContent = game.player.score;\n    if (cpuScoreEl) cpuScoreEl.textContent = game.cpu.score;\n  }\n  function resetHeroSectionBall() {\n    // Reset to single ball\n    game.balls = [{\n      x: canvas.width / 2,\n      y: canvas.height / 2,\n      vx: (Math.random() > 0.5 ? 1 : -1) * 6,\n      vy: (Math.random() - 0.5) * 6,\n      radius: 12,\n      maxSpeed: 15,\n      trail: [],\n      glow: 0,\n      glowDirection: 1\n    }];\n  }\n  function checkHeroSectionGameEnd() {\n    if (game.player.score >= 5) {\n      pongSounds.gameOver(); // 🔊 Game over sound\n      updateHeroSectionMessage((0, _i18n.t)('game.pong.youWin'));\n      window.heroSectionGameActive = false;\n      return true;\n    } else if (game.cpu.score >= 5) {\n      pongSounds.gameOver(); // 🔊 Game over sound\n      updateHeroSectionMessage((0, _i18n.t)('game.pong.fizWins'));\n      window.heroSectionGameActive = false;\n      return true;\n    }\n    return false;\n  }\n  function updateHeroSection() {\n    if (!window.heroSectionGameActive || !window.heroSectionGameStarted) return;\n\n    // Calculate game progression\n    var gameTime = Date.now() - game.startTime;\n    var timeInSeconds = gameTime / 1000;\n\n    // Progressive speed increase\n    game.speedMultiplier = 1 + Math.floor(timeInSeconds / 8) * 0.25;\n\n    // Spawn extra balls occasionally\n    if (timeInSeconds > 12 && gameTime - game.lastBallSpawn > 12000 && game.balls.length < 3) {\n      var newBall = {\n        x: canvas.width / 2,\n        y: canvas.height / 2,\n        vx: (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 3),\n        vy: (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 3),\n        radius: 8 + Math.random() * 6,\n        maxSpeed: 18,\n        trail: [],\n        glow: 0,\n        glowDirection: 1\n      };\n      game.balls.push(newBall);\n      game.lastBallSpawn = gameTime;\n    }\n\n    // Update glow effects\n    game.player.glow += game.player.glowDirection * 0.04;\n    if (game.player.glow >= 1 || game.player.glow <= 0) {\n      game.player.glowDirection *= -1;\n    }\n    game.cpu.glow += game.cpu.glowDirection * 0.03;\n    if (game.cpu.glow >= 1 || game.cpu.glow <= 0) {\n      game.cpu.glowDirection *= -1;\n    }\n\n    // Player movement with trails\n    var playerSpeed = game.player.speed * (1 + game.speedMultiplier * 0.1);\n    if (game.keys.up && game.player.y > 0) {\n      game.player.y -= playerSpeed;\n      game.player.trail.push({\n        x: game.player.x + game.player.width / 2,\n        y: game.player.y + game.player.height / 2,\n        life: 1\n      });\n    }\n    if (game.keys.down && game.player.y < canvas.height - game.player.height) {\n      game.player.y += playerSpeed;\n      game.player.trail.push({\n        x: game.player.x + game.player.width / 2,\n        y: game.player.y + game.player.height / 2,\n        life: 1\n      });\n    }\n\n    // Update trails\n    game.player.trail = game.player.trail.filter(function (point) {\n      point.life -= 0.08;\n      return point.life > 0;\n    });\n    game.cpu.trail = game.cpu.trail.filter(function (point) {\n      point.life -= 0.08;\n      return point.life > 0;\n    });\n\n    // Enhanced CPU AI that tracks closest ball\n    var closestBall = game.balls[0];\n    var closestDistance = Infinity;\n    game.balls.forEach(function (ball) {\n      var distance = Math.abs(ball.x - game.cpu.x);\n      if (distance < closestDistance && ball.vx > 0) {\n        closestDistance = distance;\n        closestBall = ball;\n      }\n    });\n    if (closestBall) {\n      var cpuCenter = game.cpu.y + game.cpu.height / 2;\n      var ballCenter = closestBall.y;\n      var diff = ballCenter - cpuCenter;\n      var cpuSpeed = game.cpu.speed * (1 + game.speedMultiplier * 0.08);\n      if (Math.abs(diff) > 12) {\n        if (diff > 0 && game.cpu.y < canvas.height - game.cpu.height) {\n          game.cpu.y += cpuSpeed;\n          game.cpu.trail.push({\n            x: game.cpu.x + game.cpu.width / 2,\n            y: game.cpu.y + game.cpu.height / 2,\n            life: 1\n          });\n        } else if (diff < 0 && game.cpu.y > 0) {\n          game.cpu.y -= cpuSpeed;\n          game.cpu.trail.push({\n            x: game.cpu.x + game.cpu.width / 2,\n            y: game.cpu.y + game.cpu.height / 2,\n            life: 1\n          });\n        }\n      }\n    }\n\n    // Update all balls\n    game.balls.forEach(function (ball, ballIndex) {\n      // Update ball glow\n      ball.glow += ball.glowDirection * 0.12;\n      if (ball.glow >= 1 || ball.glow <= 0) {\n        ball.glowDirection *= -1;\n      }\n\n      // Apply speed multiplier\n      var currentVX = ball.vx * game.speedMultiplier;\n      var currentVY = ball.vy * game.speedMultiplier;\n\n      // Ball movement\n      ball.x += currentVX;\n      ball.y += currentVY;\n\n      // Add trail\n      ball.trail.push({\n        x: ball.x,\n        y: ball.y,\n        life: 1\n      });\n\n      // Limit trail length\n      if (ball.trail.length > 12) {\n        ball.trail.shift();\n      }\n\n      // Update trail\n      ball.trail = ball.trail.filter(function (point) {\n        point.life -= 0.12;\n        return point.life > 0;\n      });\n\n      // Ball collision with top/bottom walls\n      if (ball.y <= ball.radius || ball.y >= canvas.height - ball.radius) {\n        ball.vy = -ball.vy;\n        // Create particles\n        for (var i = 0; i < 3; i++) {\n          game.particles.push({\n            x: ball.x,\n            y: ball.y,\n            vx: (Math.random() - 0.5) * 8,\n            vy: (Math.random() - 0.5) * 8,\n            life: 1,\n            decay: 0.03,\n            size: 2 + Math.random() * 2,\n            color: '#3498db'\n          });\n        }\n        pongSounds.wallBounce(); // 🔊 Wall bounce sound\n      }\n\n      // Ball collision with player paddle\n      if (ball.x - ball.radius <= game.player.x + game.player.width && ball.x + ball.radius >= game.player.x && ball.y >= game.player.y && ball.y <= game.player.y + game.player.height) {\n        ball.vx = Math.abs(ball.vx);\n        var hitPos = (ball.y - game.player.y) / game.player.height;\n        ball.vy = (hitPos - 0.5) * 10;\n\n        // Create particles\n        for (var _i = 0; _i < 5; _i++) {\n          game.particles.push({\n            x: ball.x,\n            y: ball.y,\n            vx: (Math.random() - 0.5) * 10,\n            vy: (Math.random() - 0.5) * 10,\n            life: 1,\n            decay: 0.03,\n            size: 2 + Math.random() * 3,\n            color: '#3498db'\n          });\n        }\n        pongSounds.paddleHit(); // 🔊 Player paddle hit sound\n      }\n\n      // Ball collision with CPU paddle\n      if (ball.x + ball.radius >= game.cpu.x && ball.x - ball.radius <= game.cpu.x + game.cpu.width && ball.y >= game.cpu.y && ball.y <= game.cpu.y + game.cpu.height) {\n        ball.vx = -Math.abs(ball.vx);\n        var _hitPos = (ball.y - game.cpu.y) / game.cpu.height;\n        ball.vy = (_hitPos - 0.5) * 10;\n\n        // Create particles\n        for (var _i2 = 0; _i2 < 5; _i2++) {\n          game.particles.push({\n            x: ball.x,\n            y: ball.y,\n            vx: (Math.random() - 0.5) * 10,\n            vy: (Math.random() - 0.5) * 10,\n            life: 1,\n            decay: 0.03,\n            size: 2 + Math.random() * 3,\n            color: '#e74c3c'\n          });\n        }\n        pongSounds.paddleHit(); // 🔊 CPU paddle hit sound\n      }\n\n      // Scoring\n      if (ball.x < -ball.radius) {\n        game.cpu.score++;\n\n        // Create scoring particles\n        for (var _i3 = 0; _i3 < 8; _i3++) {\n          game.particles.push({\n            x: 0,\n            y: ball.y,\n            vx: Math.random() * 5,\n            vy: (Math.random() - 0.5) * 10,\n            life: 1,\n            decay: 0.02,\n            size: 3 + Math.random() * 4,\n            color: '#e74c3c'\n          });\n        }\n        pongSounds.score(); // 🔊 Score sound\n        updateHeroSectionScore();\n        if (game.balls.length > 1) {\n          game.balls.splice(ballIndex, 1);\n        } else {\n          resetHeroSectionBall();\n          if (!checkHeroSectionGameEnd()) {\n            updateHeroSectionMessage((0, _i18n.t)('game.pong.fizScores'));\n            setTimeout(function () {\n              return updateHeroSectionMessage('');\n            }, 1500);\n          }\n        }\n      } else if (ball.x > canvas.width + ball.radius) {\n        game.player.score++;\n\n        // Create scoring particles\n        for (var _i4 = 0; _i4 < 8; _i4++) {\n          game.particles.push({\n            x: canvas.width,\n            y: ball.y,\n            vx: -Math.random() * 5,\n            vy: (Math.random() - 0.5) * 10,\n            life: 1,\n            decay: 0.02,\n            size: 3 + Math.random() * 4,\n            color: '#3498db'\n          });\n        }\n        pongSounds.score(); // 🔊 Score sound\n        updateHeroSectionScore();\n        if (game.balls.length > 1) {\n          game.balls.splice(ballIndex, 1);\n        } else {\n          resetHeroSectionBall();\n          if (!checkHeroSectionGameEnd()) {\n            updateHeroSectionMessage((0, _i18n.t)('game.pong.youScore'));\n            setTimeout(function () {\n              return updateHeroSectionMessage('');\n            }, 1500);\n          }\n        }\n      }\n\n      // Speed limit\n      ball.vx = Math.max(-ball.maxSpeed, Math.min(ball.maxSpeed, ball.vx));\n      ball.vy = Math.max(-ball.maxSpeed, Math.min(ball.maxSpeed, ball.vy));\n    });\n\n    // Update particles\n    game.particles = game.particles.filter(function (particle) {\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      particle.vx *= 0.98;\n      particle.vy *= 0.98;\n      particle.life -= particle.decay;\n      return particle.life > 0;\n    });\n  }\n  function renderHeroSection() {\n    // Clear canvas completely transparent\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw animated center line\n    var lineOffset = Math.sin(Date.now() * 0.003) * 2;\n    ctx.setLineDash([15, 10]);\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.lineWidth = 4;\n    ctx.shadowBlur = 8;\n    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';\n    ctx.beginPath();\n    ctx.moveTo(canvas.width / 2 + lineOffset, 0);\n    ctx.lineTo(canvas.width / 2 + lineOffset, canvas.height);\n    ctx.stroke();\n    ctx.setLineDash([]);\n    ctx.shadowBlur = 0;\n\n    // Draw paddle trails\n    function drawHeroTrail(trail, color) {\n      trail.forEach(function (point) {\n        ctx.save();\n        ctx.globalAlpha = point.life * 0.4;\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, 3 * point.life, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      });\n    }\n    drawHeroTrail(game.player.trail, '#3498db');\n    drawHeroTrail(game.cpu.trail, '#e74c3c');\n\n    // Draw enhanced player paddle\n    ctx.save();\n    var playerGlow = 12 + game.player.glow * 8;\n    ctx.shadowBlur = playerGlow;\n    ctx.shadowColor = '#3498db';\n    var playerGradient = ctx.createLinearGradient(game.player.x, game.player.y, game.player.x + game.player.width, game.player.y + game.player.height);\n    playerGradient.addColorStop(0, '#5dade2');\n    playerGradient.addColorStop(0.5, '#3498db');\n    playerGradient.addColorStop(1, '#2980b9');\n    ctx.fillStyle = playerGradient;\n    ctx.fillRect(game.player.x, game.player.y, game.player.width, game.player.height);\n\n    // Player border\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(game.player.x, game.player.y, game.player.width, game.player.height);\n    ctx.restore();\n\n    // Draw player label with glow\n    ctx.save();\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px Inter';\n    ctx.textAlign = 'center';\n    ctx.shadowBlur = 5;\n    ctx.shadowColor = '#3498db';\n    ctx.fillText((0, _i18n.t)('game.pong.playerLabel'), game.player.x + game.player.width / 2, game.player.y - 12);\n    ctx.restore();\n\n    // Draw enhanced CPU paddle\n    ctx.save();\n    var cpuGlow = 12 + game.cpu.glow * 8;\n    ctx.shadowBlur = cpuGlow;\n    ctx.shadowColor = '#e74c3c';\n    if (cpuImage.complete) {\n      // Create rounded rectangle clipping path\n      ctx.beginPath();\n      ctx.roundRect(game.cpu.x, game.cpu.y, game.cpu.width, game.cpu.height, 6);\n      ctx.clip();\n\n      // Draw the image scaled to fit\n      var aspectRatio = cpuImage.width / cpuImage.height;\n      var paddleAspectRatio = game.cpu.width / game.cpu.height;\n      var drawWidth, drawHeight, drawX, drawY;\n      if (aspectRatio > paddleAspectRatio) {\n        drawHeight = game.cpu.height;\n        drawWidth = drawHeight * aspectRatio;\n        drawX = game.cpu.x - (drawWidth - game.cpu.width) / 2;\n        drawY = game.cpu.y;\n      } else {\n        drawWidth = game.cpu.width;\n        drawHeight = drawWidth / aspectRatio;\n        drawX = game.cpu.x;\n        drawY = game.cpu.y - (drawHeight - game.cpu.height) / 2;\n      }\n      ctx.drawImage(cpuImage, drawX, drawY, drawWidth, drawHeight);\n      ctx.restore();\n\n      // Draw animated border\n      ctx.save();\n      ctx.strokeStyle = '#e74c3c';\n      ctx.lineWidth = 3 + Math.sin(Date.now() * 0.008) * 1;\n      ctx.shadowBlur = cpuGlow;\n      ctx.shadowColor = '#e74c3c';\n      ctx.strokeRect(game.cpu.x, game.cpu.y, game.cpu.width, game.cpu.height);\n      ctx.restore();\n    } else {\n      // Fallback gradient\n      var cpuGradient = ctx.createLinearGradient(game.cpu.x, game.cpu.y, game.cpu.x + game.cpu.width, game.cpu.y + game.cpu.height);\n      cpuGradient.addColorStop(0, '#ec7063');\n      cpuGradient.addColorStop(0.5, '#e74c3c');\n      cpuGradient.addColorStop(1, '#c0392b');\n      ctx.fillStyle = cpuGradient;\n      ctx.fillRect(game.cpu.x, game.cpu.y, game.cpu.width, game.cpu.height);\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.lineWidth = 2;\n      ctx.strokeRect(game.cpu.x, game.cpu.y, game.cpu.width, game.cpu.height);\n    }\n    ctx.restore();\n\n    // Draw CPU label with glow\n    ctx.save();\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px Inter';\n    ctx.textAlign = 'center';\n    ctx.shadowBlur = 5;\n    ctx.shadowColor = '#e74c3c';\n    ctx.fillText((0, _i18n.t)('game.pong.fizLabel'), game.cpu.x + game.cpu.width / 2, game.cpu.y - 12);\n    ctx.restore();\n\n    // Draw all balls with enhanced effects\n    game.balls.forEach(function (ball) {\n      // Draw ball trail\n      ball.trail.forEach(function (point) {\n        ctx.save();\n        ctx.globalAlpha = point.life * 0.6;\n        ctx.fillStyle = 'white';\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, ball.radius * point.life * 0.9, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      });\n\n      // Draw main ball with dynamic glow\n      ctx.save();\n      var ballGlow = 20 + ball.glow * 15;\n      ctx.shadowBlur = ballGlow;\n      ctx.shadowColor = 'white';\n\n      // Outer glow ring\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.beginPath();\n      ctx.arc(ball.x, ball.y, ball.radius + 3, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Main ball with radial gradient\n      var ballGradient = ctx.createRadialGradient(ball.x - ball.radius * 0.4, ball.y - ball.radius * 0.4, 0, ball.x, ball.y, ball.radius);\n      ballGradient.addColorStop(0, '#ffffff');\n      ballGradient.addColorStop(0.6, '#f8f9fa');\n      ballGradient.addColorStop(1, '#dee2e6');\n      ctx.fillStyle = ballGradient;\n      ctx.beginPath();\n      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Highlight spot\n      ctx.fillStyle = '#ffffff';\n      ctx.beginPath();\n      ctx.arc(ball.x - ball.radius * 0.4, ball.y - ball.radius * 0.4, ball.radius * 0.4, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    });\n\n    // Render particles\n    game.particles.forEach(function (particle) {\n      ctx.save();\n      ctx.globalAlpha = particle.life;\n      ctx.fillStyle = particle.color;\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    });\n\n    // Display enhanced game info with better positioning\n    if (window.heroSectionGameStarted) {\n      var gameTime = Math.floor((Date.now() - game.startTime) / 1000);\n      var speed = game.speedMultiplier.toFixed(1);\n      ctx.save();\n      ctx.textAlign = 'center';\n      ctx.shadowBlur = 3;\n      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n\n      // Main game stats - positioned at top center\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';\n      ctx.font = 'bold 14px Inter';\n      ctx.fillText(\"\\u23F1\\uFE0F \".concat(gameTime, \"s | \\u26A1 \").concat(speed, \"x | \\uD83C\\uDFD0 \").concat(game.balls.length), canvas.width / 2, 25);\n\n      // Special effects indicators - positioned below stats with proper spacing\n      var yOffset = 50; // Start below the main stats\n\n      if (game.speedMultiplier > 1.5) {\n        ctx.fillStyle = '#f39c12';\n        ctx.font = 'bold 12px Inter';\n        ctx.fillText('🔥 SPEED MODE ACTIVATED 🔥', canvas.width / 2, yOffset);\n        yOffset += 20; // Add spacing for next element\n      }\n      if (game.balls.length > 1) {\n        ctx.fillStyle = '#e74c3c';\n        ctx.font = 'bold 12px Inter';\n        ctx.fillText('⚡ MULTI-BALL CHAOS ⚡', canvas.width / 2, yOffset);\n      }\n      ctx.restore();\n    }\n  }\n  function heroSectionGameLoop() {\n    if (!window.heroSectionGameActive) return;\n    updateHeroSection();\n    renderHeroSection();\n    window.heroSectionAnimationId = requestAnimationFrame(heroSectionGameLoop);\n  }\n\n  // Start the game loop\n  heroSectionGameLoop();\n}\n\n//# sourceURL=webpack://startbootstrap-personal/./src/js/scripts.js?\n}");

/***/ }),

/***/ "./src/locales/en/translation.json":
/*!*****************************************!*\
  !*** ./src/locales/en/translation.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("{module.exports = /*#__PURE__*/JSON.parse('{\"meta\":{\"title\":\"Fiz Rey Armesto - Computer Engineer & VR/AR Developer\",\"description\":\"Fiz Rey Armesto - Computer Engineer & VR/AR Developer. Specialized in Unity, Unreal Engine, and immersive experiences.\"},\"nav\":{\"about\":\"About\",\"experience\":\"Experience\",\"projects\":\"Projects\",\"skills\":\"Skills\",\"contact\":\"Contact\",\"darkMode\":\"Dark\",\"lightMode\":\"Light\"},\"hero\":{\"greeting\":\"Hi, I\\'m\",\"name\":\"Fiz Rey Armesto\",\"title\":\"Computer Engineer & VR/AR Developer\",\"description\":\"I create immersive experiences using Unity and Unreal Engine, specializing in VR development and innovative interactive solutions.\",\"viewWork\":\"View My Work\",\"downloadResume\":\"Download Resume\"},\"about\":{\"title\":\"About Me\",\"description\":\"I\\'m a Computer Engineer with a passion for creating immersive digital experiences. My expertise lies in VR/AR development, game programming, and cutting-edge interactive technologies.\",\"development\":{\"title\":\"Development\",\"description\":\"Unity, Unreal Engine, C#, C++\"},\"vrar\":{\"title\":\"VR/AR\",\"description\":\"Immersive experiences, VR gaming, AR applications\"},\"engineering\":{\"title\":\"Engineering\",\"description\":\"Software architecture, system design, optimization\"}},\"experience\":{\"title\":\"Professional Experience\",\"downloadResume\":\"Download Resume\",\"current\":\"Current Position\",\"present\":\"Present\",\"arsoft\":{\"position\":\"Junior Programmer\",\"company\":\"ARSOFT\",\"location\":\"Salamanca, Spain\",\"description\":\"Lead Developer for VR/AR experiences including immersive beekeeping showcases with 360° video integration. Creation of railway driving simulators and interactive educational content in Unity.\",\"internship\":{\"position\":\"Unity Developer (Internship)\",\"description\":\"Built native Meta Quest 2 surgery simulations from scratch with the UltimateXR framework for Unity.\"}},\"freelance\":{\"position\":\"Game Developer\",\"company\":\"Freelance Developer\",\"description\":\"Creating independent games and VR experiences, participating in game jams, and developing custom solutions for clients.\"}},\"education\":{\"title\":\"Education\",\"degree\":\"Computer Engineering\",\"university\":\"Universidad de Salamanca\",\"thesis\":\"Thesis: Development of a multiplayer VR video game using Unreal Engine 5.\"},\"certificates\":{\"title\":\"Certificates\",\"c1Advanced\":{\"title\":\"C1 Advanced\",\"score\":\"Score 187\",\"description\":\"Certificate of Advanced English (CAE) issued by Cambridge English Language Assessment, part of the University of Cambridge.\"},\"cProgramming\":{\"title\":\"C Programming\",\"level\":\"Basic level\",\"description\":\"Certificate for the completion of the C programming (Basic Level) (6th Edition) issued by the University of Salamanca.\"}},\"projects\":{\"title\":\"Featured Projects\",\"categories\":{\"professional\":\"Professional\",\"personal\":\"Personal\",\"gameJam\":\"Game Jam\",\"learning\":\"Learning\",\"interview\":\"Interview\"},\"beeShowcase\":{\"title\":\"Miel 79 VR/AR Beekeeping Showcase\",\"description\":\"Immersive VR experience with 360° videos showcasing bee conservation, hive exploration, and honey production processes. Features interactive virtual visits to real beehives.\"},\"eyeflow\":{\"title\":\"Eyeflow\",\"description\":\"Advanced eye-tracking VR application for medical and research applications.\"},\"renfeSimulator\":{\"title\":\"Renfe VR Machinist Simulator\",\"description\":\"Virtual Reality training simulator for Renfe machinists, allowing them to familiarize with specific scenarios before facing real situations. This technology improves their preparation, response skills and confidence in a safe and controlled environment.\"},\"vrsurvival\":{\"title\":\"VRSurvival\",\"description\":\"Multiplayer VR survival game developed with Unreal Engine 5 and VRExpansionPlugin.\",\"viewProject\":\"View Project\"},\"yabs\":{\"title\":\"YABS - Ludum Dare 55\",\"description\":\"Game created in 48 hours for Ludum Dare game jam, showcasing rapid prototyping skills.\",\"playGame\":\"Play Game\",\"ludumDare\":\"Ludum Dare\"},\"shinjukuEki\":{\"title\":\"Shinjuku-eki - Ludum Dare 57\",\"description\":\"Game created for Ludum Dare 57, featuring atmospheric gameplay and innovative mechanics.\",\"playGame\":\"Play Game\"},\"noche\":{\"title\":\"Noche - Indie Spain Jam 2023\",\"description\":\"Lead Programmer role in Spanish indie game jam, creating atmospheric horror experience.\"},\"customEditor\":{\"title\":\"UE5 Custom Editor Tools Course\",\"description\":\"Source code for advanced Unreal Engine 5 editor tools and custom development workflows.\",\"viewOnGithub\":\"View on GitHub\"},\"endlessRunner\":{\"title\":\"Endless Runner\",\"description\":\"Game made with Unity as an assignment for an interview, demonstrating core game development skills.\"}},\"skills\":{\"title\":\"Technical Skills\",\"professionalSkills\":\"Professional Skills\",\"programmingLanguages\":\"Programming Languages\",\"gameEngines\":\"Game Engines\",\"programming\":\"Programming\",\"vrar\":\"VR/AR\",\"toolsTech\":\"Tools & Tech\",\"items\":{\"unrealEngine\":\"Unreal Engine\",\"unity\":\"Unity\",\"git\":\"Git\",\"sqlNosql\":\"SQL / NoSQL\",\"linux\":\"Linux (deb)\",\"visualStudio\":\"Eclipse / Visual Studio\",\"scrum\":\"Scrum / Jira\",\"photoshop\":\"Photoshop / Lightroom\",\"realityCapture\":\"RealityCapture\",\"firebase\":\"Firebase\",\"ueBlueprints\":\"UE Blueprints\",\"vr\":\"XR\",\"csharp\":\"C#\",\"c\":\"C\",\"cpp\":\"C++\",\"python\":\"Python\",\"java\":\"Java\",\"unrealEngine45\":\"Unreal Engine 4/5\",\"vrExpansion\":\"VRExpansionPlugin\",\"csharpNet\":\"C# .NET\",\"oculusSDK\":\"Oculus SDK\",\"openXR\":\"OpenXR\",\"steamVR\":\"SteamVR\",\"handTracking\":\"Hand Tracking\",\"gitVersionControl\":\"Git / Version Control\",\"blender\":\"Blender\",\"agileDevelopment\":\"Agile Development\"}},\"contact\":{\"title\":\"Let\\'s Work Together\",\"description\":\"I\\'m always interested in new opportunities and exciting projects. Whether you need VR development, game programming, or technical consultation, let\\'s connect!\",\"email\":\"Email\",\"linkedin\":\"LinkedIn\",\"github\":\"GitHub\"},\"modal\":{\"close\":\"Close\"},\"game\":{\"pong\":{\"clickToStart\":\"Click canvas to start\",\"moveKeys\":\"W/S or ↑/↓ to move\",\"escToExit\":\"ESC to exit\",\"scrollToExplore\":\"Scroll to explore portfolio\",\"firstToWin\":\"First to 5 points wins!\",\"gameStarted\":\"Game Started!\",\"youScore\":\"You Score!\",\"fizScores\":\"FIZ Scores!\",\"youWin\":\"You Win! 🎉 Click to play again or scroll to explore\",\"fizWins\":\"FIZ Wins! 😢 Click to play again or scroll to explore\",\"youWon\":\"You Won! Click to play again\",\"fizWon\":\"FIZ Won! Click to play again\",\"playerLabel\":\"YOU\",\"fizLabel\":\"FIZ\",\"vs\":\"VS\",\"exitGame\":\"Exit Game\"}},\"footer\":{\"copyright\":\"Copyright © Fiz Rey Armesto 2025\"}}');\n\n//# sourceURL=webpack://startbootstrap-personal/./src/locales/en/translation.json?\n}");

/***/ }),

/***/ "./src/locales/es/translation.json":
/*!*****************************************!*\
  !*** ./src/locales/es/translation.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("{module.exports = /*#__PURE__*/JSON.parse('{\"meta\":{\"title\":\"Fiz Rey Armesto - Ingeniero Informático y Desarrollador VR/AR\",\"description\":\"Fiz Rey Armesto - Ingeniero Informático y Desarrollador VR/AR. Especializado en Unity, Unreal Engine y experiencias inmersivas.\"},\"nav\":{\"about\":\"Acerca de\",\"experience\":\"Experiencia\",\"projects\":\"Proyectos\",\"skills\":\"Habilidades\",\"contact\":\"Contacto\",\"darkMode\":\"Oscuro\",\"lightMode\":\"Claro\"},\"hero\":{\"greeting\":\"Hola, soy\",\"name\":\"Fiz Rey Armesto\",\"title\":\"Ingeniero Informático y Desarrollador VR/AR\",\"description\":\"Creo experiencias inmersivas usando Unity y Unreal Engine, especializándome en desarrollo VR y soluciones interactivas innovadoras.\",\"viewWork\":\"Ver Mi Trabajo\",\"downloadResume\":\"Descargar CV\"},\"about\":{\"title\":\"Sobre Mí\",\"description\":\"Soy Ingeniero Informático con pasión por crear experiencias digitales inmersivas. Mi experiencia se centra en el desarrollo VR/AR, programación de juegos y tecnologías interactivas de vanguardia.\",\"development\":{\"title\":\"Desarrollo\",\"description\":\"Unity, Unreal Engine, C#, C++, JavaScript\"},\"vrar\":{\"title\":\"VR/AR\",\"description\":\"Experiencias inmersivas, videojuegos VR, aplicaciones AR\"},\"engineering\":{\"title\":\"Ingeniería\",\"description\":\"Arquitectura de software, diseño de sistemas, optimización\"}},\"experience\":{\"title\":\"Experiencia Profesional\",\"downloadResume\":\"Descargar CV\",\"current\":\"Posición Actual\",\"present\":\"Presente\",\"arsoft\":{\"position\":\"Programador Junior\",\"company\":\"ARSOFT\",\"location\":\"Salamanca, España\",\"description\":\"Desarrollador Líder de experiencias VR/AR incluyendo showcases inmersivos de apicultura con integración de vídeo 360°. Creación de simuladores de conducción ferroviaria y contenido educativo interactivo en Unity.\",\"internship\":{\"position\":\"Desarrollador Unity (Prácticas)\",\"description\":\"Construí simulaciones quirúrgicas nativas para Meta Quest 2 desde cero con el framework UltimateXR para Unity.\"}},\"freelance\":{\"position\":\"Desarrollador de Videojuegos\",\"company\":\"Desarrollador Freelance\",\"description\":\"Creando videojuegos independientes y experiencias VR, participando en game jams y desarrollando soluciones personalizadas para clientes.\"}},\"education\":{\"title\":\"Educación\",\"degree\":\"Ingeniería Informática\",\"university\":\"Universidad de Salamanca\",\"thesis\":\"Tesis: Desarrollo de un videojuego VR multijugador usando Unreal Engine 5.\"},\"certificates\":{\"title\":\"Certificados\",\"c1Advanced\":{\"title\":\"C1 Advanced\",\"score\":\"Puntuación 187\",\"description\":\"Certificado de Inglés Avanzado (CAE) emitido por Cambridge English Language Assessment, parte de la Universidad de Cambridge.\"},\"cProgramming\":{\"title\":\"Programación C\",\"level\":\"Nivel básico\",\"description\":\"Certificado por la finalización del curso de programación C (Nivel Básico) (6ª Edición) emitido por la Universidad de Salamanca.\"}},\"projects\":{\"title\":\"Proyectos Destacados\",\"categories\":{\"professional\":\"Profesional\",\"personal\":\"Personal\",\"gameJam\":\"Game Jam\",\"learning\":\"Aprendizaje\",\"interview\":\"Entrevista\"},\"beeShowcase\":{\"title\":\"Experiencia VR/AR Apicultura Miel 79\",\"description\":\"Experiencia VR inmersiva con vídeos 360° que muestra la conservación de abejas, exploración de colmenas y procesos de producción de miel. Incluye visitas virtuales interactivas a colmenas reales.\"},\"eyeflow\":{\"title\":\"Eyeflow\",\"description\":\"Aplicación VR avanzada de seguimiento ocular para aplicaciones médicas y de investigación.\"},\"renfeSimulator\":{\"title\":\"Simulador de Realidad Virtual para formación de maquinistas\",\"description\":\"Un simulador de Realidad Virtual para entrenar a los maquinistas de Renfe, permitiéndoles familiarizarse con escenarios específicos antes de enfrentarse a situaciones reales. Gracias a esta tecnología mejoran su preparación, habilidades de respuesta y confianza en un entorno seguro y controlado.\"},\"vrsurvival\":{\"title\":\"VRSurvival\",\"description\":\"Juego VR multijugador de supervivencia desarrollado con Unreal Engine 5 y VRExpansionPlugin.\",\"viewProject\":\"Ver Proyecto\"},\"yabs\":{\"title\":\"YABS - Ludum Dare 55\",\"description\":\"Juego creado en 48 horas para la game jam Ludum Dare, mostrando habilidades de prototipado rápido.\",\"playGame\":\"Jugar\",\"ludumDare\":\"Ludum Dare\"},\"shinjukuEki\":{\"title\":\"Shinjuku-eki - Ludum Dare 57\",\"description\":\"Juego creado para Ludum Dare 57, con gameplay atmosférico y mecánicas innovadoras.\",\"playGame\":\"Jugar\"},\"noche\":{\"title\":\"Noche - Indie Spain Jam 2023\",\"description\":\"Rol de Programador Principal en la game jam española indie, creando experiencia de terror atmosférica.\"},\"customEditor\":{\"title\":\"Curso de Herramientas de Editor UE5\",\"description\":\"Código fuente para herramientas avanzadas del editor de Unreal Engine 5 y flujos de desarrollo personalizados.\",\"viewOnGithub\":\"Ver en GitHub\"},\"endlessRunner\":{\"title\":\"Endless Runner\",\"description\":\"Juego hecho con Unity como tarea para una entrevista, demostrando habilidades básicas de desarrollo de juegos.\"}},\"skills\":{\"title\":\"Habilidades Técnicas\",\"professionalSkills\":\"Habilidades Profesionales\",\"programmingLanguages\":\"Lenguajes de Programación\",\"gameEngines\":\"Motores de Juego\",\"programming\":\"Programación\",\"vrar\":\"VR/AR\",\"toolsTech\":\"Herramientas y Tecnología\",\"items\":{\"unrealEngine\":\"Unreal Engine\",\"unity\":\"Unity\",\"git\":\"Git\",\"sqlNosql\":\"SQL / NoSQL\",\"linux\":\"Linux (deb)\",\"visualStudio\":\"Eclipse / Visual Studio\",\"scrum\":\"Scrum / Jira\",\"photoshop\":\"Photoshop / Lightroom\",\"realityCapture\":\"RealityCapture\",\"firebase\":\"Firebase\",\"ueBlueprints\":\"UE Blueprints\",\"vr\":\"XR\",\"csharp\":\"C#\",\"c\":\"C\",\"cpp\":\"C++\",\"python\":\"Python\",\"java\":\"Java\",\"javascript\":\"JavaScript\",\"unrealEngine45\":\"Unreal Engine 4/5\",\"vrExpansion\":\"VRExpansionPlugin\",\"csharpNet\":\"C# .NET\",\"oculusSDK\":\"Oculus SDK\",\"openXR\":\"OpenXR\",\"steamVR\":\"SteamVR\",\"handTracking\":\"Seguimiento de Manos\",\"gitVersionControl\":\"Git / Control de Versiones\",\"blender\":\"Blender\",\"agileDevelopment\":\"Desarrollo Ágil\"}},\"contact\":{\"title\":\"Trabajemos Juntos\",\"description\":\"Siempre estoy interesado en nuevas oportunidades y proyectos emocionantes. Ya sea que necesites desarrollo VR, programación de juegos o consultoría técnica, ¡conectemos!\",\"email\":\"Email\",\"linkedin\":\"LinkedIn\",\"github\":\"GitHub\"},\"modal\":{\"close\":\"Cerrar\"},\"game\":{\"pong\":{\"clickToStart\":\"Haz clic en el canvas para empezar\",\"moveKeys\":\"W/S o ↑/↓ para mover\",\"escToExit\":\"ESC para salir\",\"scrollToExplore\":\"Desplázate para explorar el portafolio\",\"firstToWin\":\"¡El primero en llegar a 5 puntos gana!\",\"gameStarted\":\"¡Juego Iniciado!\",\"youScore\":\"¡Tú Puntuaste!\",\"fizScores\":\"¡FIZ Puntúa!\",\"youWin\":\"¡Ganaste! 🎉 Haz clic para jugar de nuevo o desplázate para explorar\",\"fizWins\":\"¡FIZ Gana! 😢 Haz clic para jugar de nuevo o desplázate para explorar\",\"youWon\":\"¡Ganaste! Haz clic para jugar de nuevo\",\"fizWon\":\"¡FIZ Ganó! Haz clic para jugar de nuevo\",\"playerLabel\":\"TÚ\",\"fizLabel\":\"FIZ\",\"vs\":\"VS\",\"exitGame\":\"Salir del Juego\"}},\"footer\":{\"copyright\":\"Copyright © Fiz Rey Armesto 2025\"}}');\n\n//# sourceURL=webpack://startbootstrap-personal/./src/locales/es/translation.json?\n}");

/***/ }),

/***/ "./src/locales/gl/translation.json":
/*!*****************************************!*\
  !*** ./src/locales/gl/translation.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("{module.exports = /*#__PURE__*/JSON.parse('{\"meta\":{\"title\":\"Fiz Rey Armesto - Enxeñeiro Informático e Desenvolvedor VR/AR\",\"description\":\"Fiz Rey Armesto - Enxeñeiro Informático e Desenvolvedor VR/AR. Especializado en Unity, Unreal Engine e experiencias inmersivas.\"},\"nav\":{\"about\":\"Acerca de\",\"experience\":\"Experiencia\",\"projects\":\"Proxectos\",\"skills\":\"Habilidades\",\"contact\":\"Contacto\",\"darkMode\":\"Escuro\",\"lightMode\":\"Claro\"},\"hero\":{\"greeting\":\"Ola, son\",\"name\":\"Fiz Rey Armesto\",\"title\":\"Enxeñeiro Informático e Desenvolvedor VR/AR\",\"description\":\"Creo experiencias inmersivas usando Unity e Unreal Engine, especializándome en desenvolvemento VR e solucións interactivas innovadoras.\",\"viewWork\":\"Ver o Meu Traballo\",\"downloadResume\":\"Descargar CV\"},\"about\":{\"title\":\"Sobre Min\",\"description\":\"Son Enxeñeiro Informático con paixón por crear experiencias dixitais inmersivas. A miña experiencia céntrase no desenvolvemento VR/AR, programación de xogos e tecnoloxías interactivas de vangarda.\",\"development\":{\"title\":\"Desenvolvemento\",\"description\":\"Unity, Unreal Engine, C#, C++, JavaScript\"},\"vrar\":{\"title\":\"VR/AR\",\"description\":\"Experiencias inmersivas, videoxogos VR, aplicacións AR\"},\"engineering\":{\"title\":\"Enxeñería\",\"description\":\"Arquitectura de software, deseño de sistemas, optimización\"}},\"experience\":{\"title\":\"Experiencia Profesional\",\"downloadResume\":\"Descargar CV\",\"current\":\"Posición Actual\",\"present\":\"Presente\",\"arsoft\":{\"position\":\"Programador Junior\",\"company\":\"ARSOFT\",\"location\":\"Salamanca, España\",\"description\":\"Desenvolvedor Líder de experiencias VR/AR incluíndo showcases inmersivos de apicultura con integración de vídeo 360°. Creación de simuladores de condución ferroviaria e contido educativo interactivo en Unity.\",\"internship\":{\"position\":\"Desenvolvedor Unity (Prácticas)\",\"description\":\"Construín simulacións cirúrxicas nativas para Meta Quest 2 desde cero co framework UltimateXR para Unity.\"}},\"freelance\":{\"position\":\"Desenvolvedor de Videoxogos\",\"company\":\"Desenvolvedor Freelance\",\"description\":\"Creando videoxogos independentes e experiencias VR, participando en game jams e desenvolvendo solucións personalizadas para clientes.\"}},\"education\":{\"title\":\"Educación\",\"degree\":\"Enxeñería Informática\",\"university\":\"Universidad de Salamanca\",\"thesis\":\"Tese: Desenvolvemento dun videoxogo VR multixogador usando Unreal Engine 5.\"},\"certificates\":{\"title\":\"Certificados\",\"c1Advanced\":{\"title\":\"C1 Advanced\",\"score\":\"Puntuación 187\",\"description\":\"Certificado de Inglés Avanzado (CAE) emitido por Cambridge English Language Assessment, parte da Universidade de Cambridge.\"},\"cProgramming\":{\"title\":\"Programación C\",\"level\":\"Nivel básico\",\"description\":\"Certificado pola finalización do curso de programación C (Nivel Básico) (6ª Edición) emitido pola Universidad de Salamanca.\"}},\"projects\":{\"title\":\"Proxectos Destacados\",\"categories\":{\"professional\":\"Profesional\",\"personal\":\"Persoal\",\"gameJam\":\"Game Jam\",\"learning\":\"Aprendizaxe\",\"interview\":\"Entrevista\"},\"beeShowcase\":{\"title\":\"Experiencia VR/AR Apicultura Miel 79\",\"description\":\"Experiencia VR inmersiva con vídeos 360° que mostra a conservación de abellas, exploración de colmeas e procesos de produción de mel. Inclúe visitas virtuais interactivas a colmeas reais.\"},\"eyeflow\":{\"title\":\"Eyeflow\",\"description\":\"Aplicación VR avanzada de seguimento ocular para aplicacións médicas e de investigación.\"},\"renfeSimulator\":{\"title\":\"Simulador de Realidade Virtual para formación de maquinistas\",\"description\":\"Un simulador de Realidade Virtual para adestrar aos maquinistas de Renfe, permitíndolles familiarizarse con escenarios específicos antes de enfrontarse a situacións reais. Grazas a esta tecnoloxía melloran a súa preparación, habilidades de resposta e confianza nun contorno seguro e controlado.\"},\"vrsurvival\":{\"title\":\"VRSurvival\",\"description\":\"Xogo VR multixogador de supervivencia desenvolvido con Unreal Engine 5 e VRExpansionPlugin.\",\"viewProject\":\"Ver Proxecto\"},\"yabs\":{\"title\":\"YABS - Ludum Dare 55\",\"description\":\"Xogo creado en 48 horas para a game jam Ludum Dare, mostrando habilidades de prototipado rápido.\",\"playGame\":\"Xogar\",\"ludumDare\":\"Ludum Dare\"},\"shinjukuEki\":{\"title\":\"Shinjuku-eki - Ludum Dare 57\",\"description\":\"Xogo creado para Ludum Dare 57, con gameplay atmosférico e mecánicas innovadoras.\",\"playGame\":\"Xogar\"},\"noche\":{\"title\":\"Noche - Indie Spain Jam 2023\",\"description\":\"Rol de Programador Principal na game jam española indie, creando experiencia de terror atmosférica.\"},\"customEditor\":{\"title\":\"Curso de Ferramentas de Editor UE5\",\"description\":\"Código fonte para ferramentas avanzadas do editor de Unreal Engine 5 e fluxos de desenvolvemento personalizados.\",\"viewOnGithub\":\"Ver en GitHub\"},\"endlessRunner\":{\"title\":\"Endless Runner\",\"description\":\"Xogo feito con Unity como tarefa para unha entrevista, demostrando habilidades básicas de desenvolvemento de xogos.\"}},\"skills\":{\"title\":\"Habilidades Técnicas\",\"professionalSkills\":\"Habilidades Profesionais\",\"programmingLanguages\":\"Linguaxes de Programación\",\"gameEngines\":\"Motores de Xogo\",\"programming\":\"Programación\",\"vrar\":\"VR/AR\",\"toolsTech\":\"Ferramentas e Tecnoloxía\",\"items\":{\"unrealEngine\":\"Unreal Engine\",\"unity\":\"Unity\",\"git\":\"Git\",\"sqlNosql\":\"SQL / NoSQL\",\"linux\":\"Linux (deb)\",\"visualStudio\":\"Eclipse / Visual Studio\",\"scrum\":\"Scrum / Jira\",\"photoshop\":\"Photoshop / Lightroom\",\"realityCapture\":\"RealityCapture\",\"firebase\":\"Firebase\",\"ueBlueprints\":\"UE Blueprints\",\"vr\":\"XR\",\"csharp\":\"C#\",\"c\":\"C\",\"cpp\":\"C++\",\"python\":\"Python\",\"java\":\"Java\",\"javascript\":\"JavaScript\",\"unrealEngine45\":\"Unreal Engine 4/5\",\"vrExpansion\":\"VRExpansionPlugin\",\"csharpNet\":\"C# .NET\",\"oculusSDK\":\"Oculus SDK\",\"openXR\":\"OpenXR\",\"steamVR\":\"SteamVR\",\"handTracking\":\"Seguimento de Mans\",\"gitVersionControl\":\"Git / Control de Versións\",\"blender\":\"Blender\",\"agileDevelopment\":\"Desenvolvemento Áxil\"}},\"contact\":{\"title\":\"Traballemos Xuntos\",\"description\":\"Sempre estou interesado en novas oportunidades e proxectos emocionantes. Xa sexa que necesites desenvolvemento VR, programación de xogos ou consultoría técnica, ¡conectemos!\",\"email\":\"Email\",\"linkedin\":\"LinkedIn\",\"github\":\"GitHub\"},\"modal\":{\"close\":\"Pechar\"},\"game\":{\"pong\":{\"clickToStart\":\"Fai clic no canvas para comezar\",\"moveKeys\":\"W/S ou ↑/↓ para mover\",\"escToExit\":\"ESC para saír\",\"scrollToExplore\":\"Desprázate para explorar o portafolio\",\"firstToWin\":\"¡O primeiro en chegar a 5 puntos gaña!\",\"gameStarted\":\"¡Xogo Iniciado!\",\"youScore\":\"¡Ti Puntuaches!\",\"fizScores\":\"¡FIZ Puntúa!\",\"youWin\":\"¡Gañaches! 🎉 Fai clic para xogar de novo ou desprázate para explorar\",\"fizWins\":\"¡FIZ Gaña! 😢 Fai clic para xogar de novo ou desprázate para explorar\",\"youWon\":\"¡Gañaches! Fai clic para xogar de novo\",\"fizWon\":\"¡FIZ Ganou! Fai clic para xogar de novo\",\"playerLabel\":\"TI\",\"fizLabel\":\"FIZ\",\"vs\":\"VS\",\"exitGame\":\"Saír do Xogo\"}},\"footer\":{\"copyright\":\"Copyright © Fiz Rey Armesto 2025\"}}');\n\n//# sourceURL=webpack://startbootstrap-personal/./src/locales/gl/translation.json?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/scripts.js");
/******/ 	
/******/ })()
;